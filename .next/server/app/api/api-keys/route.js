"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/api-keys/route";
exports.ids = ["app/api/api-keys/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fapi-keys%2Froute&page=%2Fapi%2Fapi-keys%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fapi-keys%2Froute.ts&appDir=C%3A%5CUsers%5Caksha%5CDocuments%5CGitHub%5Csalak%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Caksha%5CDocuments%5CGitHub%5Csalak&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fapi-keys%2Froute&page=%2Fapi%2Fapi-keys%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fapi-keys%2Froute.ts&appDir=C%3A%5CUsers%5Caksha%5CDocuments%5CGitHub%5Csalak%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Caksha%5CDocuments%5CGitHub%5Csalak&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_aksha_Documents_GitHub_salak_app_api_api_keys_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/api-keys/route.ts */ \"(rsc)/./app/api/api-keys/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/api-keys/route\",\n        pathname: \"/api/api-keys\",\n        filename: \"route\",\n        bundlePath: \"app/api/api-keys/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\aksha\\\\Documents\\\\GitHub\\\\salak\\\\app\\\\api\\\\api-keys\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_aksha_Documents_GitHub_salak_app_api_api_keys_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/api-keys/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZhcGkta2V5cyUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGYXBpLWtleXMlMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZhcGkta2V5cyUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNha3NoYSU1Q0RvY3VtZW50cyU1Q0dpdEh1YiU1Q3NhbGFrJTVDYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj1DJTNBJTVDVXNlcnMlNUNha3NoYSU1Q0RvY3VtZW50cyU1Q0dpdEh1YiU1Q3NhbGFrJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUN3QjtBQUNyRztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovLy8/ZDVkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCJDOlxcXFxVc2Vyc1xcXFxha3NoYVxcXFxEb2N1bWVudHNcXFxcR2l0SHViXFxcXHNhbGFrXFxcXGFwcFxcXFxhcGlcXFxcYXBpLWtleXNcXFxccm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2FwaS1rZXlzL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvYXBpLWtleXNcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL2FwaS1rZXlzL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiQzpcXFxcVXNlcnNcXFxcYWtzaGFcXFxcRG9jdW1lbnRzXFxcXEdpdEh1YlxcXFxzYWxha1xcXFxhcHBcXFxcYXBpXFxcXGFwaS1rZXlzXFxcXHJvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS9hcGkta2V5cy9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fapi-keys%2Froute&page=%2Fapi%2Fapi-keys%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fapi-keys%2Froute.ts&appDir=C%3A%5CUsers%5Caksha%5CDocuments%5CGitHub%5Csalak%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Caksha%5CDocuments%5CGitHub%5Csalak&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/api-keys/route.ts":
/*!***********************************!*\
  !*** ./app/api/api-keys/route.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase */ \"(rsc)/./lib/supabase.ts\");\n/* harmony import */ var _lib_auth_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/auth-helpers */ \"(rsc)/./lib/auth-helpers.ts\");\n/* harmony import */ var _lib_encryption__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/encryption */ \"(rsc)/./lib/encryption.ts\");\n\n\n\n\n/**\n * GET /api/api-keys - Get all API keys for the authenticated user\n * Returns only metadata, never the actual encrypted key values\n * Does NOT decrypt keys - only returns metadata fields\n */ async function GET(request) {\n    try {\n        // Log authentication attempt\n        const authHeader = request.headers.get(\"authorization\");\n        console.log(\"[API Keys GET] Auth header present:\", !!authHeader);\n        // Validate authentication - return 401 JSON if not authenticated\n        const user = await (0,_lib_auth_helpers__WEBPACK_IMPORTED_MODULE_2__.getAuthenticatedUser)(request);\n        if (!user) {\n            console.log(\"[API Keys GET] Authentication failed - no user returned\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Unauthorized\"\n            }, {\n                status: 401\n            });\n        }\n        console.log(\"[API Keys GET] User authenticated:\", user.email, \"ID:\", user.id);\n        // Validate user.id exists\n        if (!user.id || typeof user.id !== \"string\") {\n            console.error(\"Invalid user object:\", {\n                hasId: !!user.id,\n                idType: typeof user.id\n            });\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Invalid user session\"\n            }, {\n                status: 401\n            });\n        }\n        let supabase;\n        try {\n            supabase = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_1__.createServerClient)();\n        } catch (error) {\n            console.error(\"Failed to create Supabase client:\", error);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Service configuration error\"\n            }, {\n                status: 500\n            });\n        }\n        // Fetch API keys - only return metadata, never the actual encrypted key values\n        // Explicitly select only metadata fields to avoid any issues with encrypted columns\n        const { data: apiKeys, error } = await supabase.from(\"api_keys\").select(\"id, name, is_active, created_at, last_used_at\").eq(\"user_id\", user.id).order(\"created_at\", {\n            ascending: false\n        });\n        if (error) {\n            // Log full error server-side only\n            console.error(\"Get API keys Supabase error:\", {\n                message: error.message,\n                code: error.code,\n                details: error.details,\n                hint: error.hint,\n                user_id: user.id\n            });\n            // Return user-safe error message\n            // Check for specific error types that should return different status codes\n            if (error.code === \"PGRST116\" || error.message?.includes(\"permission denied\")) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Access denied\"\n                }, {\n                    status: 403\n                });\n            }\n            // Check for table/column errors\n            if (error.message?.includes(\"relation\") || error.message?.includes(\"column\") || error.message?.includes(\"does not exist\")) {\n                console.error(\"Database schema error detected:\", error.message);\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Database configuration error. Please contact support.\"\n                }, {\n                    status: 500\n                });\n            }\n            // For other database errors, return generic message\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to fetch API keys\"\n            }, {\n                status: 500\n            });\n        }\n        // Ensure we return an array even if data is null/undefined\n        const safeApiKeys = Array.isArray(apiKeys) ? apiKeys : [];\n        // Return JSON response - always JSON, never HTML\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            apiKeys: safeApiKeys\n        });\n    } catch (error) {\n        // Catch any unexpected errors (network, parsing, etc.)\n        console.error(\"Get API keys unexpected error:\", {\n            error: error instanceof Error ? error.message : String(error),\n            stack: error instanceof Error ? error.stack : undefined\n        });\n        // Return user-safe error (no stack traces) - always JSON\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Internal server error\"\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * POST /api/api-keys - Store a user-provided API key\n * Encrypts the API key using AES-256-GCM before storing\n */ async function POST(request) {\n    try {\n        const user = await (0,_lib_auth_helpers__WEBPACK_IMPORTED_MODULE_2__.getAuthenticatedUser)(request);\n        if (!user) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Unauthorized\"\n            }, {\n                status: 401\n            });\n        }\n        // Parse request body with error handling\n        let body;\n        try {\n            body = await request.json();\n        } catch (parseError) {\n            console.error(\"Failed to parse request body:\", parseError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Invalid request format\"\n            }, {\n                status: 400\n            });\n        }\n        const { name, apiKey } = body;\n        // Validate name - must exist, be a string, and have minimum length\n        if (!name || typeof name !== \"string\") {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"API Key Name is required and must be a string\"\n            }, {\n                status: 400\n            });\n        }\n        const trimmedName = name.trim();\n        if (!trimmedName) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"API Key Name is required and cannot be empty\"\n            }, {\n                status: 400\n            });\n        }\n        if (trimmedName.length < 3) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"API Key Name must be at least 3 characters long\"\n            }, {\n                status: 400\n            });\n        }\n        // Validate API key\n        if (!apiKey || typeof apiKey !== \"string\" || !apiKey.trim()) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"API key is required and must be a non-empty string\"\n            }, {\n                status: 400\n            });\n        }\n        // Validate API key format (should be a secure token)\n        if (apiKey.trim().length < 32) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"API key must be at least 32 characters long\"\n            }, {\n                status: 400\n            });\n        }\n        // All validation passed - now proceed with database operations\n        let supabase;\n        try {\n            supabase = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_1__.createServerClient)();\n        } catch (error) {\n            console.error(\"Failed to create Supabase client:\", error);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Service configuration error\"\n            }, {\n                status: 500\n            });\n        }\n        // Check if name already exists for this user\n        const { data: existing, error: checkError } = await supabase.from(\"api_keys\").select(\"id\").eq(\"user_id\", user.id).eq(\"name\", trimmedName).maybeSingle();\n        if (checkError) {\n            console.error(\"Check existing API key error:\", {\n                message: checkError.message,\n                code: checkError.code\n            });\n            // Return appropriate status based on error type\n            if (checkError.code === \"PGRST116\" || checkError.message?.includes(\"permission denied\")) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Access denied\"\n                }, {\n                    status: 403\n                });\n            }\n            // Database error checking for existing name - return 500 as this is unexpected\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to validate API key name\"\n            }, {\n                status: 500\n            });\n        }\n        if (existing) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"An API key with this name already exists\"\n            }, {\n                status: 400\n            });\n        }\n        // Encrypt the API key using AES-256-GCM\n        let encryptedData;\n        try {\n            encryptedData = (0,_lib_encryption__WEBPACK_IMPORTED_MODULE_3__.encryptApiKey)(apiKey.trim());\n        } catch (encryptionError) {\n            console.error(\"Encryption error:\", encryptionError);\n            // Check if it's a configuration error (missing secret)\n            if (encryptionError instanceof Error && encryptionError.message.includes(\"API_KEY_ENCRYPTION_SECRET\")) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Service configuration error. Please contact support.\"\n                }, {\n                    status: 500\n                });\n            }\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to encrypt API key\"\n            }, {\n                status: 500\n            });\n        }\n        // Validate encrypted data structure\n        if (!encryptedData.encrypted_key || !encryptedData.iv || !encryptedData.auth_tag) {\n            console.error(\"Invalid encryption result:\", {\n                hasEncrypted: !!encryptedData.encrypted_key,\n                hasIv: !!encryptedData.iv,\n                hasAuthTag: !!encryptedData.auth_tag\n            });\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Encryption failed\"\n            }, {\n                status: 500\n            });\n        }\n        // Store API key record with encrypted data\n        const { data: apiKeyRecord, error: createError } = await supabase.from(\"api_keys\").insert({\n            user_id: user.id,\n            name: trimmedName,\n            encrypted_key: encryptedData.encrypted_key,\n            iv: encryptedData.iv,\n            auth_tag: encryptedData.auth_tag,\n            is_active: true\n        }).select(\"id, name, is_active, created_at\").single();\n        if (createError) {\n            console.error(\"Store API key Supabase error:\", {\n                message: createError.message,\n                code: createError.code,\n                details: createError.details,\n                hint: createError.hint\n            });\n            // Try to log the action (don't fail if this fails)\n            try {\n                await (0,_lib_auth_helpers__WEBPACK_IMPORTED_MODULE_2__.logAction)(user.id, \"API Key Store\", trimmedName, \"failed\", (0,_lib_auth_helpers__WEBPACK_IMPORTED_MODULE_2__.getClientIp)(request));\n            } catch (logError) {\n                console.error(\"Failed to log action:\", logError);\n            }\n            // Return appropriate status based on error type\n            if (createError.code === \"23505\") {\n                // Unique constraint violation\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"An API key with this name already exists\"\n                }, {\n                    status: 400\n                });\n            }\n            if (createError.code === \"PGRST116\" || createError.message?.includes(\"permission denied\")) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Access denied\"\n                }, {\n                    status: 403\n                });\n            }\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to store API key\"\n            }, {\n                status: 500\n            });\n        }\n        if (!apiKeyRecord) {\n            console.error(\"Store API key returned no data\");\n            try {\n                await (0,_lib_auth_helpers__WEBPACK_IMPORTED_MODULE_2__.logAction)(user.id, \"API Key Store\", trimmedName, \"failed\", (0,_lib_auth_helpers__WEBPACK_IMPORTED_MODULE_2__.getClientIp)(request));\n            } catch (logError) {\n                console.error(\"Failed to log action:\", logError);\n            }\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to store API key\"\n            }, {\n                status: 500\n            });\n        }\n        // Log successful storage\n        try {\n            await (0,_lib_auth_helpers__WEBPACK_IMPORTED_MODULE_2__.logAction)(user.id, \"API Key Store\", `${trimmedName} (${apiKeyRecord.id})`, \"success\", (0,_lib_auth_helpers__WEBPACK_IMPORTED_MODULE_2__.getClientIp)(request));\n        } catch (logError) {\n            // Don't fail the request if logging fails\n            console.error(\"Failed to log action:\", logError);\n        }\n        // Return success - note: we don't return the actual key, user should have saved it\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            message: \"API key stored securely. It cannot be viewed again after storage.\",\n            apiKey: {\n                id: apiKeyRecord.id,\n                name: apiKeyRecord.name,\n                is_active: apiKeyRecord.is_active,\n                created_at: apiKeyRecord.created_at\n            }\n        }, {\n            status: 201\n        });\n    } catch (error) {\n        // Catch any unexpected errors (network, parsing, etc.)\n        console.error(\"Store API key unexpected error:\", error);\n        // Return user-safe error (no stack traces)\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Internal server error\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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MENBQTBDO1lBQzFDeEQsUUFBUUksS0FBSyxDQUFDLHlCQUF5Qm9EO1FBQ3pDO1FBRUEsbUZBQW1GO1FBQ25GLE9BQU9uRSxxREFBWUEsQ0FBQ2MsSUFBSSxDQUFDO1lBQ3ZCd0IsU0FBUztZQUNUVCxTQUFTO1lBQ1RrQixRQUFRO2dCQUNON0IsSUFBSTRDLGFBQWE1QyxFQUFFO2dCQUNuQjRCLE1BQU1nQixhQUFhaEIsSUFBSTtnQkFDdkJtQixXQUFXSCxhQUFhRyxTQUFTO2dCQUNqQ0csWUFBWU4sYUFBYU0sVUFBVTtZQUNyQztRQUNGLEdBQUc7WUFBRXBELFFBQVE7UUFBSTtJQUNuQixFQUFFLE9BQU9ELE9BQU87UUFDZCx1REFBdUQ7UUFDdkRKLFFBQVFJLEtBQUssQ0FBQyxtQ0FBbUNBO1FBRWpELDJDQUEyQztRQUMzQyxPQUFPZixxREFBWUEsQ0FBQ2MsSUFBSSxDQUN0QjtZQUFFQyxPQUFPO1FBQXdCLEdBQ2pDO1lBQUVDLFFBQVE7UUFBSTtJQUVsQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXBwL2FwaS9hcGkta2V5cy9yb3V0ZS50cz9lYWE3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcidcbmltcG9ydCB7IGNyZWF0ZVNlcnZlckNsaWVudCB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJ1xuaW1wb3J0IHsgZ2V0QXV0aGVudGljYXRlZFVzZXIsIGxvZ0FjdGlvbiwgZ2V0Q2xpZW50SXAgfSBmcm9tICdAL2xpYi9hdXRoLWhlbHBlcnMnXG5pbXBvcnQgeyBlbmNyeXB0QXBpS2V5IH0gZnJvbSAnQC9saWIvZW5jcnlwdGlvbidcblxuLyoqXG4gKiBHRVQgL2FwaS9hcGkta2V5cyAtIEdldCBhbGwgQVBJIGtleXMgZm9yIHRoZSBhdXRoZW50aWNhdGVkIHVzZXJcbiAqIFJldHVybnMgb25seSBtZXRhZGF0YSwgbmV2ZXIgdGhlIGFjdHVhbCBlbmNyeXB0ZWQga2V5IHZhbHVlc1xuICogRG9lcyBOT1QgZGVjcnlwdCBrZXlzIC0gb25seSByZXR1cm5zIG1ldGFkYXRhIGZpZWxkc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgLy8gTG9nIGF1dGhlbnRpY2F0aW9uIGF0dGVtcHRcbiAgICBjb25zdCBhdXRoSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpXG4gICAgY29uc29sZS5sb2coJ1tBUEkgS2V5cyBHRVRdIEF1dGggaGVhZGVyIHByZXNlbnQ6JywgISFhdXRoSGVhZGVyKVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIGF1dGhlbnRpY2F0aW9uIC0gcmV0dXJuIDQwMSBKU09OIGlmIG5vdCBhdXRoZW50aWNhdGVkXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IGdldEF1dGhlbnRpY2F0ZWRVc2VyKHJlcXVlc3QpXG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbQVBJIEtleXMgR0VUXSBBdXRoZW50aWNhdGlvbiBmYWlsZWQgLSBubyB1c2VyIHJldHVybmVkJylcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMSB9XG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1tBUEkgS2V5cyBHRVRdIFVzZXIgYXV0aGVudGljYXRlZDonLCB1c2VyLmVtYWlsLCAnSUQ6JywgdXNlci5pZClcblxuICAgIC8vIFZhbGlkYXRlIHVzZXIuaWQgZXhpc3RzXG4gICAgaWYgKCF1c2VyLmlkIHx8IHR5cGVvZiB1c2VyLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCB1c2VyIG9iamVjdDonLCB7IGhhc0lkOiAhIXVzZXIuaWQsIGlkVHlwZTogdHlwZW9mIHVzZXIuaWQgfSlcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ludmFsaWQgdXNlciBzZXNzaW9uJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAxIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBsZXQgc3VwYWJhc2VcbiAgICB0cnkge1xuICAgICAgc3VwYWJhc2UgPSBjcmVhdGVTZXJ2ZXJDbGllbnQoKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIFN1cGFiYXNlIGNsaWVudDonLCBlcnJvcilcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1NlcnZpY2UgY29uZmlndXJhdGlvbiBlcnJvcicgfSxcbiAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggQVBJIGtleXMgLSBvbmx5IHJldHVybiBtZXRhZGF0YSwgbmV2ZXIgdGhlIGFjdHVhbCBlbmNyeXB0ZWQga2V5IHZhbHVlc1xuICAgIC8vIEV4cGxpY2l0bHkgc2VsZWN0IG9ubHkgbWV0YWRhdGEgZmllbGRzIHRvIGF2b2lkIGFueSBpc3N1ZXMgd2l0aCBlbmNyeXB0ZWQgY29sdW1uc1xuICAgIGNvbnN0IHsgZGF0YTogYXBpS2V5cywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYXBpX2tleXMnKVxuICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIGlzX2FjdGl2ZSwgY3JlYXRlZF9hdCwgbGFzdF91c2VkX2F0JylcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgLy8gTG9nIGZ1bGwgZXJyb3Igc2VydmVyLXNpZGUgb25seVxuICAgICAgY29uc29sZS5lcnJvcignR2V0IEFQSSBrZXlzIFN1cGFiYXNlIGVycm9yOicsIHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgY29kZTogZXJyb3IuY29kZSxcbiAgICAgICAgZGV0YWlsczogZXJyb3IuZGV0YWlscyxcbiAgICAgICAgaGludDogZXJyb3IuaGludCxcbiAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgIH0pXG5cbiAgICAgIC8vIFJldHVybiB1c2VyLXNhZmUgZXJyb3IgbWVzc2FnZVxuICAgICAgLy8gQ2hlY2sgZm9yIHNwZWNpZmljIGVycm9yIHR5cGVzIHRoYXQgc2hvdWxkIHJldHVybiBkaWZmZXJlbnQgc3RhdHVzIGNvZGVzXG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2JyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncGVybWlzc2lvbiBkZW5pZWQnKSkge1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgeyBlcnJvcjogJ0FjY2VzcyBkZW5pZWQnIH0sXG4gICAgICAgICAgeyBzdGF0dXM6IDQwMyB9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIHRhYmxlL2NvbHVtbiBlcnJvcnNcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmVsYXRpb24nKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnY29sdW1uJykgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRGF0YWJhc2Ugc2NoZW1hIGVycm9yIGRldGVjdGVkOicsIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICB7IGVycm9yOiAnRGF0YWJhc2UgY29uZmlndXJhdGlvbiBlcnJvci4gUGxlYXNlIGNvbnRhY3Qgc3VwcG9ydC4nIH0sXG4gICAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIG90aGVyIGRhdGFiYXNlIGVycm9ycywgcmV0dXJuIGdlbmVyaWMgbWVzc2FnZVxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIGZldGNoIEFQSSBrZXlzJyB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgd2UgcmV0dXJuIGFuIGFycmF5IGV2ZW4gaWYgZGF0YSBpcyBudWxsL3VuZGVmaW5lZFxuICAgIGNvbnN0IHNhZmVBcGlLZXlzID0gQXJyYXkuaXNBcnJheShhcGlLZXlzKSA/IGFwaUtleXMgOiBbXVxuXG4gICAgLy8gUmV0dXJuIEpTT04gcmVzcG9uc2UgLSBhbHdheXMgSlNPTiwgbmV2ZXIgSFRNTFxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgYXBpS2V5czogc2FmZUFwaUtleXMsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBDYXRjaCBhbnkgdW5leHBlY3RlZCBlcnJvcnMgKG5ldHdvcmssIHBhcnNpbmcsIGV0Yy4pXG4gICAgY29uc29sZS5lcnJvcignR2V0IEFQSSBrZXlzIHVuZXhwZWN0ZWQgZXJyb3I6Jywge1xuICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgIHN0YWNrOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB1bmRlZmluZWQsXG4gICAgfSlcbiAgICBcbiAgICAvLyBSZXR1cm4gdXNlci1zYWZlIGVycm9yIChubyBzdGFjayB0cmFjZXMpIC0gYWx3YXlzIEpTT05cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogUE9TVCAvYXBpL2FwaS1rZXlzIC0gU3RvcmUgYSB1c2VyLXByb3ZpZGVkIEFQSSBrZXlcbiAqIEVuY3J5cHRzIHRoZSBBUEkga2V5IHVzaW5nIEFFUy0yNTYtR0NNIGJlZm9yZSBzdG9yaW5nXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IGdldEF1dGhlbnRpY2F0ZWRVc2VyKHJlcXVlc3QpXG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMSB9XG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gUGFyc2UgcmVxdWVzdCBib2R5IHdpdGggZXJyb3IgaGFuZGxpbmdcbiAgICBsZXQgYm9keVxuICAgIHRyeSB7XG4gICAgICBib2R5ID0gYXdhaXQgcmVxdWVzdC5qc29uKClcbiAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgcmVxdWVzdCBib2R5OicsIHBhcnNlRXJyb3IpXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIHJlcXVlc3QgZm9ybWF0JyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCB7IG5hbWUsIGFwaUtleSB9ID0gYm9keVxuXG4gICAgLy8gVmFsaWRhdGUgbmFtZSAtIG11c3QgZXhpc3QsIGJlIGEgc3RyaW5nLCBhbmQgaGF2ZSBtaW5pbXVtIGxlbmd0aFxuICAgIGlmICghbmFtZSB8fCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0FQSSBLZXkgTmFtZSBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZycgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgdHJpbW1lZE5hbWUgPSBuYW1lLnRyaW0oKVxuICAgIGlmICghdHJpbW1lZE5hbWUpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0FQSSBLZXkgTmFtZSBpcyByZXF1aXJlZCBhbmQgY2Fubm90IGJlIGVtcHR5JyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodHJpbW1lZE5hbWUubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnQVBJIEtleSBOYW1lIG11c3QgYmUgYXQgbGVhc3QgMyBjaGFyYWN0ZXJzIGxvbmcnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIEFQSSBrZXlcbiAgICBpZiAoIWFwaUtleSB8fCB0eXBlb2YgYXBpS2V5ICE9PSAnc3RyaW5nJyB8fCAhYXBpS2V5LnRyaW0oKSkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnQVBJIGtleSBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIEFQSSBrZXkgZm9ybWF0IChzaG91bGQgYmUgYSBzZWN1cmUgdG9rZW4pXG4gICAgaWYgKGFwaUtleS50cmltKCkubGVuZ3RoIDwgMzIpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0FQSSBrZXkgbXVzdCBiZSBhdCBsZWFzdCAzMiBjaGFyYWN0ZXJzIGxvbmcnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIEFsbCB2YWxpZGF0aW9uIHBhc3NlZCAtIG5vdyBwcm9jZWVkIHdpdGggZGF0YWJhc2Ugb3BlcmF0aW9uc1xuICAgIGxldCBzdXBhYmFzZVxuICAgIHRyeSB7XG4gICAgICBzdXBhYmFzZSA9IGNyZWF0ZVNlcnZlckNsaWVudCgpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgU3VwYWJhc2UgY2xpZW50OicsIGVycm9yKVxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnU2VydmljZSBjb25maWd1cmF0aW9uIGVycm9yJyB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBuYW1lIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIHVzZXJcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nLCBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdhcGlfa2V5cycpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgLmVxKCduYW1lJywgdHJpbW1lZE5hbWUpXG4gICAgICAubWF5YmVTaW5nbGUoKVxuXG4gICAgaWYgKGNoZWNrRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NoZWNrIGV4aXN0aW5nIEFQSSBrZXkgZXJyb3I6Jywge1xuICAgICAgICBtZXNzYWdlOiBjaGVja0Vycm9yLm1lc3NhZ2UsXG4gICAgICAgIGNvZGU6IGNoZWNrRXJyb3IuY29kZSxcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIFJldHVybiBhcHByb3ByaWF0ZSBzdGF0dXMgYmFzZWQgb24gZXJyb3IgdHlwZVxuICAgICAgaWYgKGNoZWNrRXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2JyB8fCBjaGVja0Vycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdwZXJtaXNzaW9uIGRlbmllZCcpKSB7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICB7IGVycm9yOiAnQWNjZXNzIGRlbmllZCcgfSxcbiAgICAgICAgICB7IHN0YXR1czogNDAzIH1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBEYXRhYmFzZSBlcnJvciBjaGVja2luZyBmb3IgZXhpc3RpbmcgbmFtZSAtIHJldHVybiA1MDAgYXMgdGhpcyBpcyB1bmV4cGVjdGVkXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gdmFsaWRhdGUgQVBJIGtleSBuYW1lJyB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0FuIEFQSSBrZXkgd2l0aCB0aGlzIG5hbWUgYWxyZWFkeSBleGlzdHMnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIEVuY3J5cHQgdGhlIEFQSSBrZXkgdXNpbmcgQUVTLTI1Ni1HQ01cbiAgICBsZXQgZW5jcnlwdGVkRGF0YVxuICAgIHRyeSB7XG4gICAgICBlbmNyeXB0ZWREYXRhID0gZW5jcnlwdEFwaUtleShhcGlLZXkudHJpbSgpKVxuICAgIH0gY2F0Y2ggKGVuY3J5cHRpb25FcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRW5jcnlwdGlvbiBlcnJvcjonLCBlbmNyeXB0aW9uRXJyb3IpXG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBjb25maWd1cmF0aW9uIGVycm9yIChtaXNzaW5nIHNlY3JldClcbiAgICAgIGlmIChlbmNyeXB0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlbmNyeXB0aW9uRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnQVBJX0tFWV9FTkNSWVBUSU9OX1NFQ1JFVCcpKSB7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICB7IGVycm9yOiAnU2VydmljZSBjb25maWd1cmF0aW9uIGVycm9yLiBQbGVhc2UgY29udGFjdCBzdXBwb3J0LicgfSxcbiAgICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gZW5jcnlwdCBBUEkga2V5JyB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBlbmNyeXB0ZWQgZGF0YSBzdHJ1Y3R1cmVcbiAgICBpZiAoIWVuY3J5cHRlZERhdGEuZW5jcnlwdGVkX2tleSB8fCAhZW5jcnlwdGVkRGF0YS5pdiB8fCAhZW5jcnlwdGVkRGF0YS5hdXRoX3RhZykge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBlbmNyeXB0aW9uIHJlc3VsdDonLCB7IGhhc0VuY3J5cHRlZDogISFlbmNyeXB0ZWREYXRhLmVuY3J5cHRlZF9rZXksIGhhc0l2OiAhIWVuY3J5cHRlZERhdGEuaXYsIGhhc0F1dGhUYWc6ICEhZW5jcnlwdGVkRGF0YS5hdXRoX3RhZyB9KVxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnRW5jcnlwdGlvbiBmYWlsZWQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFN0b3JlIEFQSSBrZXkgcmVjb3JkIHdpdGggZW5jcnlwdGVkIGRhdGFcbiAgICBjb25zdCB7IGRhdGE6IGFwaUtleVJlY29yZCwgZXJyb3I6IGNyZWF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FwaV9rZXlzJylcbiAgICAgIC5pbnNlcnQoe1xuICAgICAgICB1c2VyX2lkOiB1c2VyLmlkLFxuICAgICAgICBuYW1lOiB0cmltbWVkTmFtZSxcbiAgICAgICAgZW5jcnlwdGVkX2tleTogZW5jcnlwdGVkRGF0YS5lbmNyeXB0ZWRfa2V5LFxuICAgICAgICBpdjogZW5jcnlwdGVkRGF0YS5pdixcbiAgICAgICAgYXV0aF90YWc6IGVuY3J5cHRlZERhdGEuYXV0aF90YWcsXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgIH0pXG4gICAgICAuc2VsZWN0KCdpZCwgbmFtZSwgaXNfYWN0aXZlLCBjcmVhdGVkX2F0JylcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGNyZWF0ZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTdG9yZSBBUEkga2V5IFN1cGFiYXNlIGVycm9yOicsIHtcbiAgICAgICAgbWVzc2FnZTogY3JlYXRlRXJyb3IubWVzc2FnZSxcbiAgICAgICAgY29kZTogY3JlYXRlRXJyb3IuY29kZSxcbiAgICAgICAgZGV0YWlsczogY3JlYXRlRXJyb3IuZGV0YWlscyxcbiAgICAgICAgaGludDogY3JlYXRlRXJyb3IuaGludCxcbiAgICAgIH0pXG5cbiAgICAgIC8vIFRyeSB0byBsb2cgdGhlIGFjdGlvbiAoZG9uJ3QgZmFpbCBpZiB0aGlzIGZhaWxzKVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbG9nQWN0aW9uKHVzZXIuaWQsICdBUEkgS2V5IFN0b3JlJywgdHJpbW1lZE5hbWUsICdmYWlsZWQnLCBnZXRDbGllbnRJcChyZXF1ZXN0KSlcbiAgICAgIH0gY2F0Y2ggKGxvZ0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2cgYWN0aW9uOicsIGxvZ0Vycm9yKVxuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYXBwcm9wcmlhdGUgc3RhdHVzIGJhc2VkIG9uIGVycm9yIHR5cGVcbiAgICAgIGlmIChjcmVhdGVFcnJvci5jb2RlID09PSAnMjM1MDUnKSB7XG4gICAgICAgIC8vIFVuaXF1ZSBjb25zdHJhaW50IHZpb2xhdGlvblxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgeyBlcnJvcjogJ0FuIEFQSSBrZXkgd2l0aCB0aGlzIG5hbWUgYWxyZWFkeSBleGlzdHMnIH0sXG4gICAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKGNyZWF0ZUVycm9yLmNvZGUgPT09ICdQR1JTVDExNicgfHwgY3JlYXRlRXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3Blcm1pc3Npb24gZGVuaWVkJykpIHtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgIHsgZXJyb3I6ICdBY2Nlc3MgZGVuaWVkJyB9LFxuICAgICAgICAgIHsgc3RhdHVzOiA0MDMgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ZhaWxlZCB0byBzdG9yZSBBUEkga2V5JyB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoIWFwaUtleVJlY29yZCkge1xuICAgICAgY29uc29sZS5lcnJvcignU3RvcmUgQVBJIGtleSByZXR1cm5lZCBubyBkYXRhJylcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGxvZ0FjdGlvbih1c2VyLmlkLCAnQVBJIEtleSBTdG9yZScsIHRyaW1tZWROYW1lLCAnZmFpbGVkJywgZ2V0Q2xpZW50SXAocmVxdWVzdCkpXG4gICAgICB9IGNhdGNoIChsb2dFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9nIGFjdGlvbjonLCBsb2dFcnJvcilcbiAgICAgIH1cbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ZhaWxlZCB0byBzdG9yZSBBUEkga2V5JyB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBMb2cgc3VjY2Vzc2Z1bCBzdG9yYWdlXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGxvZ0FjdGlvbih1c2VyLmlkLCAnQVBJIEtleSBTdG9yZScsIGAke3RyaW1tZWROYW1lfSAoJHthcGlLZXlSZWNvcmQuaWR9KWAsICdzdWNjZXNzJywgZ2V0Q2xpZW50SXAocmVxdWVzdCkpXG4gICAgfSBjYXRjaCAobG9nRXJyb3IpIHtcbiAgICAgIC8vIERvbid0IGZhaWwgdGhlIHJlcXVlc3QgaWYgbG9nZ2luZyBmYWlsc1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvZyBhY3Rpb246JywgbG9nRXJyb3IpXG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHN1Y2Nlc3MgLSBub3RlOiB3ZSBkb24ndCByZXR1cm4gdGhlIGFjdHVhbCBrZXksIHVzZXIgc2hvdWxkIGhhdmUgc2F2ZWQgaXRcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6ICdBUEkga2V5IHN0b3JlZCBzZWN1cmVseS4gSXQgY2Fubm90IGJlIHZpZXdlZCBhZ2FpbiBhZnRlciBzdG9yYWdlLicsXG4gICAgICBhcGlLZXk6IHtcbiAgICAgICAgaWQ6IGFwaUtleVJlY29yZC5pZCxcbiAgICAgICAgbmFtZTogYXBpS2V5UmVjb3JkLm5hbWUsXG4gICAgICAgIGlzX2FjdGl2ZTogYXBpS2V5UmVjb3JkLmlzX2FjdGl2ZSxcbiAgICAgICAgY3JlYXRlZF9hdDogYXBpS2V5UmVjb3JkLmNyZWF0ZWRfYXQsXG4gICAgICB9LFxuICAgIH0sIHsgc3RhdHVzOiAyMDEgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBDYXRjaCBhbnkgdW5leHBlY3RlZCBlcnJvcnMgKG5ldHdvcmssIHBhcnNpbmcsIGV0Yy4pXG4gICAgY29uc29sZS5lcnJvcignU3RvcmUgQVBJIGtleSB1bmV4cGVjdGVkIGVycm9yOicsIGVycm9yKVxuICAgIFxuICAgIC8vIFJldHVybiB1c2VyLXNhZmUgZXJyb3IgKG5vIHN0YWNrIHRyYWNlcylcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKVxuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJjcmVhdGVTZXJ2ZXJDbGllbnQiLCJnZXRBdXRoZW50aWNhdGVkVXNlciIsImxvZ0FjdGlvbiIsImdldENsaWVudElwIiwiZW5jcnlwdEFwaUtleSIsIkdFVCIsInJlcXVlc3QiLCJhdXRoSGVhZGVyIiwiaGVhZGVycyIsImdldCIsImNvbnNvbGUiLCJsb2ciLCJ1c2VyIiwianNvbiIsImVycm9yIiwic3RhdHVzIiwiZW1haWwiLCJpZCIsImhhc0lkIiwiaWRUeXBlIiwic3VwYWJhc2UiLCJkYXRhIiwiYXBpS2V5cyIsImZyb20iLCJzZWxlY3QiLCJlcSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibWVzc2FnZSIsImNvZGUiLCJkZXRhaWxzIiwiaGludCIsInVzZXJfaWQiLCJpbmNsdWRlcyIsInNhZmVBcGlLZXlzIiwiQXJyYXkiLCJpc0FycmF5Iiwic3VjY2VzcyIsIkVycm9yIiwiU3RyaW5nIiwic3RhY2siLCJ1bmRlZmluZWQiLCJQT1NUIiwiYm9keSIsInBhcnNlRXJyb3IiLCJuYW1lIiwiYXBpS2V5IiwidHJpbW1lZE5hbWUiLCJ0cmltIiwibGVuZ3RoIiwiZXhpc3RpbmciLCJjaGVja0Vycm9yIiwibWF5YmVTaW5nbGUiLCJlbmNyeXB0ZWREYXRhIiwiZW5jcnlwdGlvbkVycm9yIiwiZW5jcnlwdGVkX2tleSIsIml2IiwiYXV0aF90YWciLCJoYXNFbmNyeXB0ZWQiLCJoYXNJdiIsImhhc0F1dGhUYWciLCJhcGlLZXlSZWNvcmQiLCJjcmVhdGVFcnJvciIsImluc2VydCIsImlzX2FjdGl2ZSIsInNpbmdsZSIsImxvZ0Vycm9yIiwiY3JlYXRlZF9hdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/api-keys/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/auth-helpers.ts":
/*!*****************************!*\
  !*** ./lib/auth-helpers.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAuthenticatedUser: () => (/* binding */ getAuthenticatedUser),\n/* harmony export */   getAuthenticatedUserFromSession: () => (/* binding */ getAuthenticatedUserFromSession),\n/* harmony export */   getClientIp: () => (/* binding */ getClientIp),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   logAction: () => (/* binding */ logAction)\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(rsc)/./lib/supabase.ts\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/index.mjs\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsonwebtoken */ \"(rsc)/./node_modules/jsonwebtoken/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jsonwebtoken__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n/**\n * Create a Supabase client for token validation\n * Uses anon key for validating user tokens (service role key bypasses auth checks)\n */ function createAuthClient() {\n    const supabaseUrl = \"https://owwuktgpundilqkdbvxj.supabase.co\";\n    const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im93d3VrdGdwdW5kaWxxa2RidnhqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5MTY5NTMsImV4cCI6MjA4MDQ5Mjk1M30.rt3AkjsQrEjbZImOGlcVLLYS1-WbHtit7Zu7hkEJn4s\";\n    if (!supabaseUrl || !supabaseAnonKey) {\n        throw new Error(\"Missing Supabase environment variables for auth\");\n    }\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__.createClient)(supabaseUrl, supabaseAnonKey, {\n        auth: {\n            autoRefreshToken: false,\n            persistSession: false\n        }\n    });\n}\n/**\n * Get authenticated user from JWT token in Authorization header or httpOnly cookie\n * Tries Supabase session token validation first (for Supabase Auth tokens),\n * then falls back to custom JWT verification (for JWTs signed with JWT_SECRET)\n * This supports both Supabase Auth tokens and custom JWTs\n */ async function getAuthenticatedUser(request) {\n    try {\n        let token = null;\n        // First, try to get token from Authorization header\n        const authHeader = request.headers.get(\"authorization\");\n        if (authHeader && authHeader.startsWith(\"Bearer \")) {\n            token = authHeader.replace(\"Bearer \", \"\").trim();\n        }\n        // If no token in header, try to get from httpOnly cookie (for iframe authentication)\n        if (!token) {\n            // Try both cookie names for compatibility\n            const accessTokenCookie = request.cookies.get(\"accessToken\")?.value;\n            const tokenCookie = request.cookies.get(\"token\")?.value;\n            if (accessTokenCookie) {\n                token = accessTokenCookie;\n                console.log(\"[Auth] Using accessToken from httpOnly cookie for iframe authentication\");\n            } else if (tokenCookie) {\n                token = tokenCookie;\n                console.log(\"[Auth] Using token from httpOnly cookie for iframe authentication\");\n            }\n        }\n        if (!token || token.length < 20) {\n            console.error(\"[Auth] Missing or invalid token (checked both header and cookie)\");\n            return null;\n        }\n        if (!token || token.length < 20) {\n            console.error(\"[Auth] Invalid token format (too short)\");\n            return null;\n        }\n        // First, try Supabase session token validation (for Supabase Auth tokens)\n        // Use anon key client for token validation (service role bypasses auth)\n        try {\n            console.log(\"[Auth] Attempting Supabase token validation...\");\n            const authClient = createAuthClient();\n            const { data: { user: supabaseUser }, error: supabaseError } = await authClient.auth.getUser(token);\n            if (supabaseError) {\n                console.log(\"[Auth] Supabase token validation error:\", supabaseError.message);\n            }\n            if (!supabaseError && supabaseUser) {\n                console.log(\"[Auth] Supabase token validated successfully for user:\", supabaseUser.email);\n                // Token is a valid Supabase token, get user profile using server client\n                // Match strictly by auth user id (UUID), not by email\n                const supabase = (0,_supabase__WEBPACK_IMPORTED_MODULE_0__.createServerClient)();\n                let { data: dbUser, error: dbError } = await supabase.from(\"users\").select(\"id, email, name, role\").eq(\"id\", supabaseUser.id).maybeSingle();\n                // If not found by UUID, try by email as fallback\n                if (!dbUser && !dbError && supabaseUser.email) {\n                    console.log(\"[Auth] User not found by UUID, trying by email:\", supabaseUser.email);\n                    const { data: emailUser, error: emailError } = await supabase.from(\"users\").select(\"id, email, name, role\").eq(\"email\", supabaseUser.email).maybeSingle();\n                    if (!emailError && emailUser) {\n                        console.log(\"[Auth] User found by email\");\n                        dbUser = emailUser;\n                        dbError = null;\n                    }\n                }\n                if (!dbError && dbUser) {\n                    console.log(\"[Auth] User profile retrieved successfully\");\n                    return dbUser;\n                }\n                // User profile not found - try to create it from auth.users data\n                // Only create if no row is found (dbUser is null)\n                if (!dbUser) {\n                    console.log(\"[Auth] User profile not found, attempting to create from auth.users\");\n                    const createdUser = await ensureUserProfileExists(supabaseUser.id, supabaseUser.email, supabaseUser.user_metadata);\n                    if (createdUser) {\n                        return createdUser;\n                    }\n                }\n                if (dbError) {\n                    console.error(\"[Auth] Error retrieving user from database:\", dbError.message, \"User ID:\", supabaseUser.id);\n                }\n            } else if (supabaseError) {\n                console.error(\"[Auth] Supabase token validation failed:\", supabaseError.message, supabaseError.status);\n            }\n        } catch (supabaseAuthError) {\n            console.error(\"[Auth] Supabase auth client error:\", supabaseAuthError);\n        }\n        // Fallback: Try custom JWT verification (for custom JWTs signed with JWT_SECRET)\n        // This maintains backward compatibility for custom tokens\n        const jwtSecret = process.env.JWT_SECRET;\n        if (jwtSecret) {\n            try {\n                const decoded = jsonwebtoken__WEBPACK_IMPORTED_MODULE_1___default().verify(token, jwtSecret);\n                const userId = decoded.sub || decoded.user_id || decoded.id;\n                if (userId) {\n                    console.log(\"[Auth] Custom JWT validated successfully for user ID:\", userId);\n                    const supabase = (0,_supabase__WEBPACK_IMPORTED_MODULE_0__.createServerClient)();\n                    const { data: dbUser, error } = await supabase.from(\"users\").select(\"id, email, name, role\").eq(\"id\", userId).maybeSingle();\n                    if (!error && dbUser) {\n                        console.log(\"[Auth] User profile retrieved from custom JWT\");\n                        return dbUser;\n                    }\n                }\n            } catch (jwtError) {\n                // JWT verification failed - this is expected if it's a Supabase token\n                if (jwtError instanceof (jsonwebtoken__WEBPACK_IMPORTED_MODULE_1___default().JsonWebTokenError)) {\n                    console.error(\"[Auth] Custom JWT verification failed:\", jwtError.message);\n                }\n            }\n        } else {\n            console.warn(\"[Auth] JWT_SECRET not configured - custom JWT verification disabled\");\n        }\n        // If both methods failed, return null\n        console.error(\"[Auth] All authentication methods failed\");\n        return null;\n    } catch (error) {\n        console.error(\"[Auth] Unexpected auth error:\", error);\n        return null;\n    }\n}\n/**\n * Check if user is admin\n */ function isAdmin(user) {\n    return user?.role === \"admin\";\n}\n/**\n * Log system action\n */ async function logAction(userId, action, resource, status, ipAddress = null) {\n    try {\n        const supabase = (0,_supabase__WEBPACK_IMPORTED_MODULE_0__.createServerClient)();\n        await supabase.from(\"system_logs\").insert({\n            user_id: userId,\n            action,\n            resource,\n            status,\n            ip_address: ipAddress\n        });\n    } catch (error) {\n        console.error(\"Failed to log action:\", error);\n    }\n}\n/**\n * Get authenticated user from Supabase session token\n * This validates the JWT token from Authorization header\n * Uses anon key for token validation (service role bypasses auth checks)\n */ async function getAuthenticatedUserFromSession(request) {\n    try {\n        const authHeader = request.headers.get(\"authorization\");\n        if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n            return null;\n        }\n        const token = authHeader.replace(\"Bearer \", \"\").trim();\n        // Verify token with Supabase using anon key (for proper token validation)\n        const authClient = createAuthClient();\n        const { data: { user }, error } = await authClient.auth.getUser(token);\n        if (error || !user) {\n            console.error(\"[Session Auth] Token validation failed:\", error?.message);\n            return null;\n        }\n        // Get user profile from database using server client (for RLS bypass)\n        // Match strictly by auth user id (UUID), not by email\n        const supabase = (0,_supabase__WEBPACK_IMPORTED_MODULE_0__.createServerClient)();\n        const { data: dbUser, error: dbError } = await supabase.from(\"users\").select(\"id, email, name, role\").eq(\"id\", user.id).maybeSingle();\n        if (!dbError && dbUser) {\n            return dbUser;\n        }\n        // User profile not found - try to create it from auth.users data\n        // Only create if no row is found (dbUser is null)\n        if (!dbUser) {\n            console.log(\"[Session Auth] User profile not found, attempting to create from auth.users\");\n            const createdUser = await ensureUserProfileExists(user.id, user.email, user.user_metadata);\n            if (createdUser) {\n                return createdUser;\n            }\n        }\n        if (dbError) {\n            console.error(\"[Session Auth] Error retrieving user profile:\", dbError.message);\n        }\n        return null;\n    } catch (error) {\n        console.error(\"[Session Auth] Unexpected error:\", error);\n        return null;\n    }\n}\n/**\n * Ensure user profile exists in public.users table\n * Creates the profile if it doesn't exist, using data from auth.users\n * Matches users strictly by auth user id (UUID), not by email\n * Only creates if no row is found - does not attempt insert if user already exists\n * Returns the user profile or null if creation fails\n */ async function ensureUserProfileExists(authUserId, authUserEmail, authUserMetadata) {\n    try {\n        const supabase = (0,_supabase__WEBPACK_IMPORTED_MODULE_0__.createServerClient)();\n        // Check if user already exists - match strictly by auth user id (UUID)\n        const { data: existingUser, error: checkError } = await supabase.from(\"users\").select(\"id, email, name, role\").eq(\"id\", authUserId).maybeSingle();\n        // If user exists, return it immediately\n        if (!checkError && existingUser) {\n            return existingUser;\n        }\n        // Only create if no row is found (existingUser is null)\n        // Do not attempt to insert if user already exists\n        if (existingUser) {\n            console.log(\"[Auth] User profile already exists, skipping creation\");\n            return null;\n        }\n        // User doesn't exist, create it\n        console.log(\"[Auth] User profile not found, creating from auth.users data:\", authUserId);\n        const userName = authUserMetadata?.full_name || authUserMetadata?.name || authUserEmail?.split(\"@\")[0] || \"User\";\n        const userRole = authUserMetadata?.role || \"user\";\n        const { data: newUser, error: createError } = await supabase.from(\"users\").insert({\n            id: authUserId,\n            email: authUserEmail || \"\",\n            name: userName,\n            role: userRole\n        }).select(\"id, email, name, role\").maybeSingle();\n        if (createError) {\n            // Handle duplicate key errors (user was created between check and insert)\n            if (createError.code === \"23505\") {\n                // User was created by another process (trigger or concurrent request), fetch it\n                console.log(\"[Auth] User profile was created concurrently, fetching existing record\");\n                const { data: fetchedUser, error: fetchError } = await supabase.from(\"users\").select(\"id, email, name, role\").eq(\"id\", authUserId).maybeSingle();\n                if (!fetchError && fetchedUser) {\n                    return fetchedUser;\n                }\n            }\n            // Handle duplicate email errors gracefully (shouldn't happen with UUID matching, but handle it)\n            if (createError.code === \"23505\" && createError.message?.includes(\"email\")) {\n                console.warn(\"[Auth] Duplicate email detected, but user lookup by UUID should prevent this\");\n                // Try to fetch by UUID instead\n                const { data: fetchedUser, error: fetchError } = await supabase.from(\"users\").select(\"id, email, name, role\").eq(\"id\", authUserId).maybeSingle();\n                if (!fetchError && fetchedUser) {\n                    return fetchedUser;\n                }\n            }\n            console.error(\"[Auth] Failed to create user profile:\", createError.message, \"Code:\", createError.code);\n            return null;\n        }\n        if (newUser) {\n            console.log(\"[Auth] User profile created successfully:\", newUser.email);\n            return newUser;\n        }\n        // If insert succeeded but no data returned, try fetching\n        const { data: fetchedUser, error: fetchError } = await supabase.from(\"users\").select(\"id, email, name, role\").eq(\"id\", authUserId).maybeSingle();\n        if (!fetchError && fetchedUser) {\n            return fetchedUser;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"[Auth] Error ensuring user profile exists:\", error);\n        return null;\n    }\n}\n/**\n * Get client IP address from request\n */ function getClientIp(request) {\n    const forwarded = request.headers.get(\"x-forwarded-for\");\n    const realIp = request.headers.get(\"x-real-ip\");\n    if (forwarded) {\n        return forwarded.split(\",\")[0].trim();\n    }\n    return realIp || null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU13RSxTQUFTNUUsUUFBUUcsT0FBTyxDQUFDQyxHQUFHLENBQUM7SUFFbkMsSUFBSXVFLFdBQVc7UUFDYixPQUFPQSxVQUFVVCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQzNELElBQUk7SUFDckM7SUFFQSxPQUFPcUUsVUFBVTtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9hdXRoLWhlbHBlcnMudHM/OTQwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJ1xuaW1wb3J0IHsgY3JlYXRlU2VydmVyQ2xpZW50IH0gZnJvbSAnLi9zdXBhYmFzZSdcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcbmltcG9ydCBqd3QgZnJvbSAnanNvbndlYnRva2VuJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhlbnRpY2F0ZWRVc2VyIHtcbiAgaWQ6IHN0cmluZ1xuICBlbWFpbDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICByb2xlOiAndXNlcicgfCAnYWRtaW4nXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgU3VwYWJhc2UgY2xpZW50IGZvciB0b2tlbiB2YWxpZGF0aW9uXG4gKiBVc2VzIGFub24ga2V5IGZvciB2YWxpZGF0aW5nIHVzZXIgdG9rZW5zIChzZXJ2aWNlIHJvbGUga2V5IGJ5cGFzc2VzIGF1dGggY2hlY2tzKVxuICovXG5mdW5jdGlvbiBjcmVhdGVBdXRoQ2xpZW50KCkge1xuICBjb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTFxuICBjb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWVxuXG4gIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlQW5vbktleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBTdXBhYmFzZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIGF1dGgnKVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgYXV0aDoge1xuICAgICAgYXV0b1JlZnJlc2hUb2tlbjogZmFsc2UsXG4gICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgfSxcbiAgfSlcbn1cblxuLyoqXG4gKiBHZXQgYXV0aGVudGljYXRlZCB1c2VyIGZyb20gSldUIHRva2VuIGluIEF1dGhvcml6YXRpb24gaGVhZGVyIG9yIGh0dHBPbmx5IGNvb2tpZVxuICogVHJpZXMgU3VwYWJhc2Ugc2Vzc2lvbiB0b2tlbiB2YWxpZGF0aW9uIGZpcnN0IChmb3IgU3VwYWJhc2UgQXV0aCB0b2tlbnMpLFxuICogdGhlbiBmYWxscyBiYWNrIHRvIGN1c3RvbSBKV1QgdmVyaWZpY2F0aW9uIChmb3IgSldUcyBzaWduZWQgd2l0aCBKV1RfU0VDUkVUKVxuICogVGhpcyBzdXBwb3J0cyBib3RoIFN1cGFiYXNlIEF1dGggdG9rZW5zIGFuZCBjdXN0b20gSldUc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aGVudGljYXRlZFVzZXIoXG4gIHJlcXVlc3Q6IE5leHRSZXF1ZXN0XG4pOiBQcm9taXNlPEF1dGhlbnRpY2F0ZWRVc2VyIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGxldCB0b2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGxcblxuICAgIC8vIEZpcnN0LCB0cnkgdG8gZ2V0IHRva2VuIGZyb20gQXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICBjb25zdCBhdXRoSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpXG4gICAgaWYgKGF1dGhIZWFkZXIgJiYgYXV0aEhlYWRlci5zdGFydHNXaXRoKCdCZWFyZXIgJykpIHtcbiAgICAgIHRva2VuID0gYXV0aEhlYWRlci5yZXBsYWNlKCdCZWFyZXIgJywgJycpLnRyaW0oKVxuICAgIH1cblxuICAgIC8vIElmIG5vIHRva2VuIGluIGhlYWRlciwgdHJ5IHRvIGdldCBmcm9tIGh0dHBPbmx5IGNvb2tpZSAoZm9yIGlmcmFtZSBhdXRoZW50aWNhdGlvbilcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICAvLyBUcnkgYm90aCBjb29raWUgbmFtZXMgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuQ29va2llID0gcmVxdWVzdC5jb29raWVzLmdldCgnYWNjZXNzVG9rZW4nKT8udmFsdWVcbiAgICAgIGNvbnN0IHRva2VuQ29va2llID0gcmVxdWVzdC5jb29raWVzLmdldCgndG9rZW4nKT8udmFsdWVcblxuICAgICAgaWYgKGFjY2Vzc1Rva2VuQ29va2llKSB7XG4gICAgICAgIHRva2VuID0gYWNjZXNzVG9rZW5Db29raWVcbiAgICAgICAgY29uc29sZS5sb2coJ1tBdXRoXSBVc2luZyBhY2Nlc3NUb2tlbiBmcm9tIGh0dHBPbmx5IGNvb2tpZSBmb3IgaWZyYW1lIGF1dGhlbnRpY2F0aW9uJylcbiAgICAgIH0gZWxzZSBpZiAodG9rZW5Db29raWUpIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbkNvb2tpZVxuICAgICAgICBjb25zb2xlLmxvZygnW0F1dGhdIFVzaW5nIHRva2VuIGZyb20gaHR0cE9ubHkgY29va2llIGZvciBpZnJhbWUgYXV0aGVudGljYXRpb24nKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdG9rZW4gfHwgdG9rZW4ubGVuZ3RoIDwgMjApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBdXRoXSBNaXNzaW5nIG9yIGludmFsaWQgdG9rZW4gKGNoZWNrZWQgYm90aCBoZWFkZXIgYW5kIGNvb2tpZSknKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0b2tlbiB8fCB0b2tlbi5sZW5ndGggPCAyMCkge1xuICAgICAgY29uc29sZS5lcnJvcignW0F1dGhdIEludmFsaWQgdG9rZW4gZm9ybWF0ICh0b28gc2hvcnQpJylcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gRmlyc3QsIHRyeSBTdXBhYmFzZSBzZXNzaW9uIHRva2VuIHZhbGlkYXRpb24gKGZvciBTdXBhYmFzZSBBdXRoIHRva2VucylcbiAgICAvLyBVc2UgYW5vbiBrZXkgY2xpZW50IGZvciB0b2tlbiB2YWxpZGF0aW9uIChzZXJ2aWNlIHJvbGUgYnlwYXNzZXMgYXV0aClcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1tBdXRoXSBBdHRlbXB0aW5nIFN1cGFiYXNlIHRva2VuIHZhbGlkYXRpb24uLi4nKVxuICAgICAgY29uc3QgYXV0aENsaWVudCA9IGNyZWF0ZUF1dGhDbGllbnQoKVxuICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXI6IHN1cGFiYXNlVXNlciB9LCBlcnJvcjogc3VwYWJhc2VFcnJvciB9ID0gYXdhaXQgYXV0aENsaWVudC5hdXRoLmdldFVzZXIodG9rZW4pXG5cbiAgICAgIGlmIChzdXBhYmFzZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQXV0aF0gU3VwYWJhc2UgdG9rZW4gdmFsaWRhdGlvbiBlcnJvcjonLCBzdXBhYmFzZUVycm9yLm1lc3NhZ2UpXG4gICAgICB9XG5cbiAgICAgIGlmICghc3VwYWJhc2VFcnJvciAmJiBzdXBhYmFzZVVzZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tBdXRoXSBTdXBhYmFzZSB0b2tlbiB2YWxpZGF0ZWQgc3VjY2Vzc2Z1bGx5IGZvciB1c2VyOicsIHN1cGFiYXNlVXNlci5lbWFpbClcbiAgICAgICAgXG4gICAgICAgIC8vIFRva2VuIGlzIGEgdmFsaWQgU3VwYWJhc2UgdG9rZW4sIGdldCB1c2VyIHByb2ZpbGUgdXNpbmcgc2VydmVyIGNsaWVudFxuICAgICAgICAvLyBNYXRjaCBzdHJpY3RseSBieSBhdXRoIHVzZXIgaWQgKFVVSUQpLCBub3QgYnkgZW1haWxcbiAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTZXJ2ZXJDbGllbnQoKVxuICAgICAgICBsZXQgeyBkYXRhOiBkYlVzZXIsIGVycm9yOiBkYkVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgLnNlbGVjdCgnaWQsIGVtYWlsLCBuYW1lLCByb2xlJylcbiAgICAgICAgICAuZXEoJ2lkJywgc3VwYWJhc2VVc2VyLmlkKVxuICAgICAgICAgIC5tYXliZVNpbmdsZSgpXG5cbiAgICAgICAgLy8gSWYgbm90IGZvdW5kIGJ5IFVVSUQsIHRyeSBieSBlbWFpbCBhcyBmYWxsYmFja1xuICAgICAgICBpZiAoIWRiVXNlciAmJiAhZGJFcnJvciAmJiBzdXBhYmFzZVVzZXIuZW1haWwpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW0F1dGhdIFVzZXIgbm90IGZvdW5kIGJ5IFVVSUQsIHRyeWluZyBieSBlbWFpbDonLCBzdXBhYmFzZVVzZXIuZW1haWwpXG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBlbWFpbFVzZXIsIGVycm9yOiBlbWFpbEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgICAgIC5zZWxlY3QoJ2lkLCBlbWFpbCwgbmFtZSwgcm9sZScpXG4gICAgICAgICAgICAuZXEoJ2VtYWlsJywgc3VwYWJhc2VVc2VyLmVtYWlsKVxuICAgICAgICAgICAgLm1heWJlU2luZ2xlKClcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWVtYWlsRXJyb3IgJiYgZW1haWxVc2VyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0F1dGhdIFVzZXIgZm91bmQgYnkgZW1haWwnKVxuICAgICAgICAgICAgZGJVc2VyID0gZW1haWxVc2VyXG4gICAgICAgICAgICBkYkVycm9yID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGJFcnJvciAmJiBkYlVzZXIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW0F1dGhdIFVzZXIgcHJvZmlsZSByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICAgICAgICByZXR1cm4gZGJVc2VyIGFzIEF1dGhlbnRpY2F0ZWRVc2VyXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVzZXIgcHJvZmlsZSBub3QgZm91bmQgLSB0cnkgdG8gY3JlYXRlIGl0IGZyb20gYXV0aC51c2VycyBkYXRhXG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGlmIG5vIHJvdyBpcyBmb3VuZCAoZGJVc2VyIGlzIG51bGwpXG4gICAgICAgIGlmICghZGJVc2VyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tBdXRoXSBVc2VyIHByb2ZpbGUgbm90IGZvdW5kLCBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBmcm9tIGF1dGgudXNlcnMnKVxuICAgICAgICAgIGNvbnN0IGNyZWF0ZWRVc2VyID0gYXdhaXQgZW5zdXJlVXNlclByb2ZpbGVFeGlzdHMoXG4gICAgICAgICAgICBzdXBhYmFzZVVzZXIuaWQsXG4gICAgICAgICAgICBzdXBhYmFzZVVzZXIuZW1haWwsXG4gICAgICAgICAgICBzdXBhYmFzZVVzZXIudXNlcl9tZXRhZGF0YVxuICAgICAgICAgIClcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY3JlYXRlZFVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVkVXNlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGRiRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQXV0aF0gRXJyb3IgcmV0cmlldmluZyB1c2VyIGZyb20gZGF0YWJhc2U6JywgZGJFcnJvci5tZXNzYWdlLCAnVXNlciBJRDonLCBzdXBhYmFzZVVzZXIuaWQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3VwYWJhc2VFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbQXV0aF0gU3VwYWJhc2UgdG9rZW4gdmFsaWRhdGlvbiBmYWlsZWQ6Jywgc3VwYWJhc2VFcnJvci5tZXNzYWdlLCBzdXBhYmFzZUVycm9yLnN0YXR1cylcbiAgICAgIH1cbiAgICB9IGNhdGNoIChzdXBhYmFzZUF1dGhFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0F1dGhdIFN1cGFiYXNlIGF1dGggY2xpZW50IGVycm9yOicsIHN1cGFiYXNlQXV0aEVycm9yKVxuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrOiBUcnkgY3VzdG9tIEpXVCB2ZXJpZmljYXRpb24gKGZvciBjdXN0b20gSldUcyBzaWduZWQgd2l0aCBKV1RfU0VDUkVUKVxuICAgIC8vIFRoaXMgbWFpbnRhaW5zIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIGN1c3RvbSB0b2tlbnNcbiAgICBjb25zdCBqd3RTZWNyZXQgPSBwcm9jZXNzLmVudi5KV1RfU0VDUkVUXG4gICAgaWYgKGp3dFNlY3JldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGp3dC52ZXJpZnkodG9rZW4sIGp3dFNlY3JldCkgYXMgand0Lkp3dFBheWxvYWRcbiAgICAgICAgY29uc3QgdXNlcklkID0gZGVjb2RlZC5zdWIgfHwgZGVjb2RlZC51c2VyX2lkIHx8IGRlY29kZWQuaWRcblxuICAgICAgICBpZiAodXNlcklkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tBdXRoXSBDdXN0b20gSldUIHZhbGlkYXRlZCBzdWNjZXNzZnVsbHkgZm9yIHVzZXIgSUQ6JywgdXNlcklkKVxuICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlU2VydmVyQ2xpZW50KClcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IGRiVXNlciwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAgICAgLnNlbGVjdCgnaWQsIGVtYWlsLCBuYW1lLCByb2xlJylcbiAgICAgICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXG4gICAgICAgICAgICAubWF5YmVTaW5nbGUoKVxuXG4gICAgICAgICAgaWYgKCFlcnJvciAmJiBkYlVzZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQXV0aF0gVXNlciBwcm9maWxlIHJldHJpZXZlZCBmcm9tIGN1c3RvbSBKV1QnKVxuICAgICAgICAgICAgcmV0dXJuIGRiVXNlciBhcyBBdXRoZW50aWNhdGVkVXNlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoand0RXJyb3IpIHtcbiAgICAgICAgLy8gSldUIHZlcmlmaWNhdGlvbiBmYWlsZWQgLSB0aGlzIGlzIGV4cGVjdGVkIGlmIGl0J3MgYSBTdXBhYmFzZSB0b2tlblxuICAgICAgICBpZiAoand0RXJyb3IgaW5zdGFuY2VvZiBqd3QuSnNvbldlYlRva2VuRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQXV0aF0gQ3VzdG9tIEpXVCB2ZXJpZmljYXRpb24gZmFpbGVkOicsIGp3dEVycm9yLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdbQXV0aF0gSldUX1NFQ1JFVCBub3QgY29uZmlndXJlZCAtIGN1c3RvbSBKV1QgdmVyaWZpY2F0aW9uIGRpc2FibGVkJylcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIG1ldGhvZHMgZmFpbGVkLCByZXR1cm4gbnVsbFxuICAgIGNvbnNvbGUuZXJyb3IoJ1tBdXRoXSBBbGwgYXV0aGVudGljYXRpb24gbWV0aG9kcyBmYWlsZWQnKVxuICAgIHJldHVybiBudWxsXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW0F1dGhdIFVuZXhwZWN0ZWQgYXV0aCBlcnJvcjonLCBlcnJvcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdXNlciBpcyBhZG1pblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBZG1pbih1c2VyOiBBdXRoZW50aWNhdGVkVXNlciB8IG51bGwpOiBib29sZWFuIHtcbiAgcmV0dXJuIHVzZXI/LnJvbGUgPT09ICdhZG1pbidcbn1cblxuLyoqXG4gKiBMb2cgc3lzdGVtIGFjdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9nQWN0aW9uKFxuICB1c2VySWQ6IHN0cmluZyB8IG51bGwsXG4gIGFjdGlvbjogc3RyaW5nLFxuICByZXNvdXJjZTogc3RyaW5nIHwgbnVsbCxcbiAgc3RhdHVzOiAnc3VjY2VzcycgfCAnZmFpbGVkJyxcbiAgaXBBZGRyZXNzOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTZXJ2ZXJDbGllbnQoKVxuICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ3N5c3RlbV9sb2dzJykuaW5zZXJ0KHtcbiAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgIGFjdGlvbixcbiAgICAgIHJlc291cmNlLFxuICAgICAgc3RhdHVzLFxuICAgICAgaXBfYWRkcmVzczogaXBBZGRyZXNzLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvZyBhY3Rpb246JywgZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYXV0aGVudGljYXRlZCB1c2VyIGZyb20gU3VwYWJhc2Ugc2Vzc2lvbiB0b2tlblxuICogVGhpcyB2YWxpZGF0ZXMgdGhlIEpXVCB0b2tlbiBmcm9tIEF1dGhvcml6YXRpb24gaGVhZGVyXG4gKiBVc2VzIGFub24ga2V5IGZvciB0b2tlbiB2YWxpZGF0aW9uIChzZXJ2aWNlIHJvbGUgYnlwYXNzZXMgYXV0aCBjaGVja3MpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBdXRoZW50aWNhdGVkVXNlckZyb21TZXNzaW9uKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KTogUHJvbWlzZTxBdXRoZW50aWNhdGVkVXNlciB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhdXRoSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpXG5cbiAgICBpZiAoIWF1dGhIZWFkZXIgfHwgIWF1dGhIZWFkZXIuc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHRva2VuID0gYXV0aEhlYWRlci5yZXBsYWNlKCdCZWFyZXIgJywgJycpLnRyaW0oKVxuXG4gICAgLy8gVmVyaWZ5IHRva2VuIHdpdGggU3VwYWJhc2UgdXNpbmcgYW5vbiBrZXkgKGZvciBwcm9wZXIgdG9rZW4gdmFsaWRhdGlvbilcbiAgICBjb25zdCBhdXRoQ2xpZW50ID0gY3JlYXRlQXV0aENsaWVudCgpXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3IgfSA9IGF3YWl0IGF1dGhDbGllbnQuYXV0aC5nZXRVc2VyKHRva2VuKVxuXG4gICAgaWYgKGVycm9yIHx8ICF1c2VyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU2Vzc2lvbiBBdXRoXSBUb2tlbiB2YWxpZGF0aW9uIGZhaWxlZDonLCBlcnJvcj8ubWVzc2FnZSlcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gR2V0IHVzZXIgcHJvZmlsZSBmcm9tIGRhdGFiYXNlIHVzaW5nIHNlcnZlciBjbGllbnQgKGZvciBSTFMgYnlwYXNzKVxuICAgIC8vIE1hdGNoIHN0cmljdGx5IGJ5IGF1dGggdXNlciBpZCAoVVVJRCksIG5vdCBieSBlbWFpbFxuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlU2VydmVyQ2xpZW50KClcbiAgICBjb25zdCB7IGRhdGE6IGRiVXNlciwgZXJyb3I6IGRiRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgLnNlbGVjdCgnaWQsIGVtYWlsLCBuYW1lLCByb2xlJylcbiAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgLm1heWJlU2luZ2xlKClcblxuICAgIGlmICghZGJFcnJvciAmJiBkYlVzZXIpIHtcbiAgICAgIHJldHVybiBkYlVzZXIgYXMgQXV0aGVudGljYXRlZFVzZXJcbiAgICB9XG5cbiAgICAvLyBVc2VyIHByb2ZpbGUgbm90IGZvdW5kIC0gdHJ5IHRvIGNyZWF0ZSBpdCBmcm9tIGF1dGgudXNlcnMgZGF0YVxuICAgIC8vIE9ubHkgY3JlYXRlIGlmIG5vIHJvdyBpcyBmb3VuZCAoZGJVc2VyIGlzIG51bGwpXG4gICAgaWYgKCFkYlVzZXIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbU2Vzc2lvbiBBdXRoXSBVc2VyIHByb2ZpbGUgbm90IGZvdW5kLCBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBmcm9tIGF1dGgudXNlcnMnKVxuICAgICAgY29uc3QgY3JlYXRlZFVzZXIgPSBhd2FpdCBlbnN1cmVVc2VyUHJvZmlsZUV4aXN0cyhcbiAgICAgICAgdXNlci5pZCxcbiAgICAgICAgdXNlci5lbWFpbCxcbiAgICAgICAgdXNlci51c2VyX21ldGFkYXRhXG4gICAgICApXG4gICAgICBcbiAgICAgIGlmIChjcmVhdGVkVXNlcikge1xuICAgICAgICByZXR1cm4gY3JlYXRlZFVzZXJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGJFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1Nlc3Npb24gQXV0aF0gRXJyb3IgcmV0cmlldmluZyB1c2VyIHByb2ZpbGU6JywgZGJFcnJvci5tZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTZXNzaW9uIEF1dGhdIFVuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSB1c2VyIHByb2ZpbGUgZXhpc3RzIGluIHB1YmxpYy51c2VycyB0YWJsZVxuICogQ3JlYXRlcyB0aGUgcHJvZmlsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LCB1c2luZyBkYXRhIGZyb20gYXV0aC51c2Vyc1xuICogTWF0Y2hlcyB1c2VycyBzdHJpY3RseSBieSBhdXRoIHVzZXIgaWQgKFVVSUQpLCBub3QgYnkgZW1haWxcbiAqIE9ubHkgY3JlYXRlcyBpZiBubyByb3cgaXMgZm91bmQgLSBkb2VzIG5vdCBhdHRlbXB0IGluc2VydCBpZiB1c2VyIGFscmVhZHkgZXhpc3RzXG4gKiBSZXR1cm5zIHRoZSB1c2VyIHByb2ZpbGUgb3IgbnVsbCBpZiBjcmVhdGlvbiBmYWlsc1xuICovXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVVc2VyUHJvZmlsZUV4aXN0cyhcbiAgYXV0aFVzZXJJZDogc3RyaW5nLFxuICBhdXRoVXNlckVtYWlsOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGF1dGhVc2VyTWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWRcbik6IFByb21pc2U8QXV0aGVudGljYXRlZFVzZXIgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTZXJ2ZXJDbGllbnQoKVxuXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBhbHJlYWR5IGV4aXN0cyAtIG1hdGNoIHN0cmljdGx5IGJ5IGF1dGggdXNlciBpZCAoVVVJRClcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nVXNlciwgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgLnNlbGVjdCgnaWQsIGVtYWlsLCBuYW1lLCByb2xlJylcbiAgICAgIC5lcSgnaWQnLCBhdXRoVXNlcklkKVxuICAgICAgLm1heWJlU2luZ2xlKClcblxuICAgIC8vIElmIHVzZXIgZXhpc3RzLCByZXR1cm4gaXQgaW1tZWRpYXRlbHlcbiAgICBpZiAoIWNoZWNrRXJyb3IgJiYgZXhpc3RpbmdVc2VyKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdVc2VyIGFzIEF1dGhlbnRpY2F0ZWRVc2VyXG4gICAgfVxuXG4gICAgLy8gT25seSBjcmVhdGUgaWYgbm8gcm93IGlzIGZvdW5kIChleGlzdGluZ1VzZXIgaXMgbnVsbClcbiAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byBpbnNlcnQgaWYgdXNlciBhbHJlYWR5IGV4aXN0c1xuICAgIGlmIChleGlzdGluZ1VzZXIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbQXV0aF0gVXNlciBwcm9maWxlIGFscmVhZHkgZXhpc3RzLCBza2lwcGluZyBjcmVhdGlvbicpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIFVzZXIgZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0XG4gICAgY29uc29sZS5sb2coJ1tBdXRoXSBVc2VyIHByb2ZpbGUgbm90IGZvdW5kLCBjcmVhdGluZyBmcm9tIGF1dGgudXNlcnMgZGF0YTonLCBhdXRoVXNlcklkKVxuICAgIFxuICAgIGNvbnN0IHVzZXJOYW1lID0gYXV0aFVzZXJNZXRhZGF0YT8uZnVsbF9uYW1lIHx8IFxuICAgICAgICAgICAgICAgICAgICAgYXV0aFVzZXJNZXRhZGF0YT8ubmFtZSB8fCBcbiAgICAgICAgICAgICAgICAgICAgIGF1dGhVc2VyRW1haWw/LnNwbGl0KCdAJylbMF0gfHwgXG4gICAgICAgICAgICAgICAgICAgICAnVXNlcidcbiAgICBcbiAgICBjb25zdCB1c2VyUm9sZSA9IGF1dGhVc2VyTWV0YWRhdGE/LnJvbGUgfHwgJ3VzZXInXG5cbiAgICBjb25zdCB7IGRhdGE6IG5ld1VzZXIsIGVycm9yOiBjcmVhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAuaW5zZXJ0KHtcbiAgICAgICAgaWQ6IGF1dGhVc2VySWQsXG4gICAgICAgIGVtYWlsOiBhdXRoVXNlckVtYWlsIHx8ICcnLFxuICAgICAgICBuYW1lOiB1c2VyTmFtZSxcbiAgICAgICAgcm9sZTogdXNlclJvbGUsXG4gICAgICB9KVxuICAgICAgLnNlbGVjdCgnaWQsIGVtYWlsLCBuYW1lLCByb2xlJylcbiAgICAgIC5tYXliZVNpbmdsZSgpXG5cbiAgICBpZiAoY3JlYXRlRXJyb3IpIHtcbiAgICAgIC8vIEhhbmRsZSBkdXBsaWNhdGUga2V5IGVycm9ycyAodXNlciB3YXMgY3JlYXRlZCBiZXR3ZWVuIGNoZWNrIGFuZCBpbnNlcnQpXG4gICAgICBpZiAoY3JlYXRlRXJyb3IuY29kZSA9PT0gJzIzNTA1Jykge1xuICAgICAgICAvLyBVc2VyIHdhcyBjcmVhdGVkIGJ5IGFub3RoZXIgcHJvY2VzcyAodHJpZ2dlciBvciBjb25jdXJyZW50IHJlcXVlc3QpLCBmZXRjaCBpdFxuICAgICAgICBjb25zb2xlLmxvZygnW0F1dGhdIFVzZXIgcHJvZmlsZSB3YXMgY3JlYXRlZCBjb25jdXJyZW50bHksIGZldGNoaW5nIGV4aXN0aW5nIHJlY29yZCcpXG4gICAgICAgIGNvbnN0IHsgZGF0YTogZmV0Y2hlZFVzZXIsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgLnNlbGVjdCgnaWQsIGVtYWlsLCBuYW1lLCByb2xlJylcbiAgICAgICAgICAuZXEoJ2lkJywgYXV0aFVzZXJJZClcbiAgICAgICAgICAubWF5YmVTaW5nbGUoKVxuICAgICAgICBcbiAgICAgICAgaWYgKCFmZXRjaEVycm9yICYmIGZldGNoZWRVc2VyKSB7XG4gICAgICAgICAgcmV0dXJuIGZldGNoZWRVc2VyIGFzIEF1dGhlbnRpY2F0ZWRVc2VyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIGR1cGxpY2F0ZSBlbWFpbCBlcnJvcnMgZ3JhY2VmdWxseSAoc2hvdWxkbid0IGhhcHBlbiB3aXRoIFVVSUQgbWF0Y2hpbmcsIGJ1dCBoYW5kbGUgaXQpXG4gICAgICBpZiAoY3JlYXRlRXJyb3IuY29kZSA9PT0gJzIzNTA1JyAmJiBjcmVhdGVFcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnZW1haWwnKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tBdXRoXSBEdXBsaWNhdGUgZW1haWwgZGV0ZWN0ZWQsIGJ1dCB1c2VyIGxvb2t1cCBieSBVVUlEIHNob3VsZCBwcmV2ZW50IHRoaXMnKVxuICAgICAgICAvLyBUcnkgdG8gZmV0Y2ggYnkgVVVJRCBpbnN0ZWFkXG4gICAgICAgIGNvbnN0IHsgZGF0YTogZmV0Y2hlZFVzZXIsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgLnNlbGVjdCgnaWQsIGVtYWlsLCBuYW1lLCByb2xlJylcbiAgICAgICAgICAuZXEoJ2lkJywgYXV0aFVzZXJJZClcbiAgICAgICAgICAubWF5YmVTaW5nbGUoKVxuICAgICAgICBcbiAgICAgICAgaWYgKCFmZXRjaEVycm9yICYmIGZldGNoZWRVc2VyKSB7XG4gICAgICAgICAgcmV0dXJuIGZldGNoZWRVc2VyIGFzIEF1dGhlbnRpY2F0ZWRVc2VyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5lcnJvcignW0F1dGhdIEZhaWxlZCB0byBjcmVhdGUgdXNlciBwcm9maWxlOicsIGNyZWF0ZUVycm9yLm1lc3NhZ2UsICdDb2RlOicsIGNyZWF0ZUVycm9yLmNvZGUpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGlmIChuZXdVc2VyKSB7XG4gICAgICBjb25zb2xlLmxvZygnW0F1dGhdIFVzZXIgcHJvZmlsZSBjcmVhdGVkIHN1Y2Nlc3NmdWxseTonLCBuZXdVc2VyLmVtYWlsKVxuICAgICAgcmV0dXJuIG5ld1VzZXIgYXMgQXV0aGVudGljYXRlZFVzZXJcbiAgICB9XG5cbiAgICAvLyBJZiBpbnNlcnQgc3VjY2VlZGVkIGJ1dCBubyBkYXRhIHJldHVybmVkLCB0cnkgZmV0Y2hpbmdcbiAgICBjb25zdCB7IGRhdGE6IGZldGNoZWRVc2VyLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAuc2VsZWN0KCdpZCwgZW1haWwsIG5hbWUsIHJvbGUnKVxuICAgICAgLmVxKCdpZCcsIGF1dGhVc2VySWQpXG4gICAgICAubWF5YmVTaW5nbGUoKVxuXG4gICAgaWYgKCFmZXRjaEVycm9yICYmIGZldGNoZWRVc2VyKSB7XG4gICAgICByZXR1cm4gZmV0Y2hlZFVzZXIgYXMgQXV0aGVudGljYXRlZFVzZXJcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tBdXRoXSBFcnJvciBlbnN1cmluZyB1c2VyIHByb2ZpbGUgZXhpc3RzOicsIGVycm9yKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgY2xpZW50IElQIGFkZHJlc3MgZnJvbSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRJcChyZXF1ZXN0OiBOZXh0UmVxdWVzdCk6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCBmb3J3YXJkZWQgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCd4LWZvcndhcmRlZC1mb3InKVxuICBjb25zdCByZWFsSXAgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCd4LXJlYWwtaXAnKVxuXG4gIGlmIChmb3J3YXJkZWQpIHtcbiAgICByZXR1cm4gZm9yd2FyZGVkLnNwbGl0KCcsJylbMF0udHJpbSgpXG4gIH1cblxuICByZXR1cm4gcmVhbElwIHx8IG51bGxcbn1cblxuIl0sIm5hbWVzIjpbImNyZWF0ZVNlcnZlckNsaWVudCIsImNyZWF0ZUNsaWVudCIsImp3dCIsImNyZWF0ZUF1dGhDbGllbnQiLCJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsIkVycm9yIiwiYXV0aCIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImdldEF1dGhlbnRpY2F0ZWRVc2VyIiwicmVxdWVzdCIsInRva2VuIiwiYXV0aEhlYWRlciIsImhlYWRlcnMiLCJnZXQiLCJzdGFydHNXaXRoIiwicmVwbGFjZSIsInRyaW0iLCJhY2Nlc3NUb2tlbkNvb2tpZSIsImNvb2tpZXMiLCJ2YWx1ZSIsInRva2VuQ29va2llIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImVycm9yIiwiYXV0aENsaWVudCIsImRhdGEiLCJ1c2VyIiwic3VwYWJhc2VVc2VyIiwic3VwYWJhc2VFcnJvciIsImdldFVzZXIiLCJtZXNzYWdlIiwiZW1haWwiLCJzdXBhYmFzZSIsImRiVXNlciIsImRiRXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJpZCIsIm1heWJlU2luZ2xlIiwiZW1haWxVc2VyIiwiZW1haWxFcnJvciIsImNyZWF0ZWRVc2VyIiwiZW5zdXJlVXNlclByb2ZpbGVFeGlzdHMiLCJ1c2VyX21ldGFkYXRhIiwic3RhdHVzIiwic3VwYWJhc2VBdXRoRXJyb3IiLCJqd3RTZWNyZXQiLCJKV1RfU0VDUkVUIiwiZGVjb2RlZCIsInZlcmlmeSIsInVzZXJJZCIsInN1YiIsInVzZXJfaWQiLCJqd3RFcnJvciIsIkpzb25XZWJUb2tlbkVycm9yIiwid2FybiIsImlzQWRtaW4iLCJyb2xlIiwibG9nQWN0aW9uIiwiYWN0aW9uIiwicmVzb3VyY2UiLCJpcEFkZHJlc3MiLCJpbnNlcnQiLCJpcF9hZGRyZXNzIiwiZ2V0QXV0aGVudGljYXRlZFVzZXJGcm9tU2Vzc2lvbiIsImF1dGhVc2VySWQiLCJhdXRoVXNlckVtYWlsIiwiYXV0aFVzZXJNZXRhZGF0YSIsImV4aXN0aW5nVXNlciIsImNoZWNrRXJyb3IiLCJ1c2VyTmFtZSIsImZ1bGxfbmFtZSIsIm5hbWUiLCJzcGxpdCIsInVzZXJSb2xlIiwibmV3VXNlciIsImNyZWF0ZUVycm9yIiwiY29kZSIsImZldGNoZWRVc2VyIiwiZmV0Y2hFcnJvciIsImluY2x1ZGVzIiwiZ2V0Q2xpZW50SXAiLCJmb3J3YXJkZWQiLCJyZWFsSXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/auth-helpers.ts\n");

/***/ }),

/***/ "(rsc)/./lib/encryption.ts":
/*!***************************!*\
  !*** ./lib/encryption.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptApiKey: () => (/* binding */ decryptApiKey),\n/* harmony export */   encryptApiKey: () => (/* binding */ encryptApiKey)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\r\n * Encryption utility for API keys using AES-256-GCM\r\n * \r\n * Requirements:\r\n * - API_KEY_ENCRYPTION_SECRET must be set in environment variables\r\n * - Uses SHA-256 to derive a 32-byte AES key from the secret\r\n * - Always generates a random 12-byte IV for each encryption\r\n * - Returns encrypted_key, iv, and auth_tag as Base64 strings\r\n */ const ALGORITHM = \"aes-256-gcm\";\nconst IV_LENGTH = 12 // 12 bytes for GCM\n;\nconst KEY_LENGTH = 32 // 32 bytes for AES-256\n;\n/**\r\n * Get and validate the encryption secret from environment\r\n * Derives a 32-byte AES key using SHA-256\r\n */ function getEncryptionKey() {\n    const secret = process.env.API_KEY_ENCRYPTION_SECRET;\n    if (!secret) {\n        throw new Error(\"API_KEY_ENCRYPTION_SECRET environment variable is required but not set. \" + \"Please set it in your .env file.\");\n    }\n    if (secret.trim().length === 0) {\n        throw new Error(\"API_KEY_ENCRYPTION_SECRET environment variable cannot be empty. \" + \"Please set a valid secret in your .env file.\");\n    }\n    // Derive a 32-byte key using SHA-256\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha256\").update(secret).digest();\n}\n/**\r\n * Encrypt a plaintext string using AES-256-GCM\r\n * \r\n * @param plaintext - The text to encrypt\r\n * @returns Object with encrypted_key, iv, and auth_tag (all Base64 encoded)\r\n * @throws Error if encryption fails or inputs are invalid\r\n */ function encryptApiKey(plaintext) {\n    try {\n        // Validate input\n        if (!plaintext || typeof plaintext !== \"string\") {\n            throw new Error(\"Plaintext must be a non-empty string\");\n        }\n        if (plaintext.trim().length === 0) {\n            throw new Error(\"Plaintext cannot be empty\");\n        }\n        // Get encryption key\n        const key = getEncryptionKey();\n        // Generate random IV (12 bytes for GCM)\n        const iv = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(IV_LENGTH);\n        // Create cipher\n        const cipher = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createCipheriv)(ALGORITHM, key, iv);\n        // Encrypt\n        let encrypted = cipher.update(plaintext, \"utf8\");\n        encrypted = Buffer.concat([\n            encrypted,\n            cipher.final()\n        ]);\n        // Get authentication tag\n        const authTag = cipher.getAuthTag();\n        // Return Base64 encoded strings\n        return {\n            encrypted_key: encrypted.toString(\"base64\"),\n            iv: iv.toString(\"base64\"),\n            auth_tag: authTag.toString(\"base64\")\n        };\n    } catch (error) {\n        // Re-throw with context if it's our validation error\n        if (error instanceof Error && error.message.includes(\"Plaintext\")) {\n            throw error;\n        }\n        // Wrap crypto errors\n        throw new Error(`Encryption failed: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n}\n/**\r\n * Decrypt an encrypted API key using AES-256-GCM\r\n * \r\n * @param encrypted_key - Base64 encoded encrypted data\r\n * @param iv - Base64 encoded initialization vector\r\n * @param auth_tag - Base64 encoded authentication tag\r\n * @returns Decrypted plaintext string\r\n * @throws Error if decryption fails or inputs are invalid\r\n */ function decryptApiKey(encrypted_key, iv, auth_tag) {\n    try {\n        // Validate all required fields exist\n        if (!encrypted_key || typeof encrypted_key !== \"string\" || encrypted_key.trim().length === 0) {\n            throw new Error(\"encrypted_key is required and must be a non-empty string\");\n        }\n        if (!iv || typeof iv !== \"string\" || iv.trim().length === 0) {\n            throw new Error(\"iv is required and must be a non-empty string\");\n        }\n        if (!auth_tag || typeof auth_tag !== \"string\" || auth_tag.trim().length === 0) {\n            throw new Error(\"auth_tag is required and must be a non-empty string\");\n        }\n        // Get decryption key\n        const key = getEncryptionKey();\n        // Decode Base64 strings\n        let encryptedBuffer;\n        let ivBuffer;\n        let authTagBuffer;\n        try {\n            encryptedBuffer = Buffer.from(encrypted_key, \"base64\");\n            ivBuffer = Buffer.from(iv, \"base64\");\n            authTagBuffer = Buffer.from(auth_tag, \"base64\");\n        } catch (decodeError) {\n            throw new Error(\"Invalid Base64 encoding in encrypted data\");\n        }\n        // Validate IV length\n        if (ivBuffer.length !== IV_LENGTH) {\n            throw new Error(`Invalid IV length: expected ${IV_LENGTH} bytes, got ${ivBuffer.length}`);\n        }\n        // Validate auth tag length (GCM auth tag is always 16 bytes)\n        if (authTagBuffer.length !== 16) {\n            throw new Error(`Invalid auth tag length: expected 16 bytes, got ${authTagBuffer.length}`);\n        }\n        // Create decipher\n        const decipher = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createDecipheriv)(ALGORITHM, key, ivBuffer);\n        decipher.setAuthTag(authTagBuffer);\n        // Decrypt\n        let decrypted = decipher.update(encryptedBuffer);\n        decrypted = Buffer.concat([\n            decrypted,\n            decipher.final()\n        ]);\n        return decrypted.toString(\"utf8\");\n    } catch (error) {\n        // Re-throw validation errors as-is\n        if (error instanceof Error && (error.message.includes(\"required\") || error.message.includes(\"Invalid\") || error.message.includes(\"length\"))) {\n            throw error;\n        }\n        // Wrap crypto errors (including authentication failures)\n        throw new Error(`Decryption failed: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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InNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhhc2gsIHJhbmRvbUJ5dGVzLCBjcmVhdGVDaXBoZXJpdiwgY3JlYXRlRGVjaXBoZXJpdiB9IGZyb20gJ2NyeXB0bydcclxuXHJcbi8qKlxyXG4gKiBFbmNyeXB0aW9uIHV0aWxpdHkgZm9yIEFQSSBrZXlzIHVzaW5nIEFFUy0yNTYtR0NNXHJcbiAqIFxyXG4gKiBSZXF1aXJlbWVudHM6XHJcbiAqIC0gQVBJX0tFWV9FTkNSWVBUSU9OX1NFQ1JFVCBtdXN0IGJlIHNldCBpbiBlbnZpcm9ubWVudCB2YXJpYWJsZXNcclxuICogLSBVc2VzIFNIQS0yNTYgdG8gZGVyaXZlIGEgMzItYnl0ZSBBRVMga2V5IGZyb20gdGhlIHNlY3JldFxyXG4gKiAtIEFsd2F5cyBnZW5lcmF0ZXMgYSByYW5kb20gMTItYnl0ZSBJViBmb3IgZWFjaCBlbmNyeXB0aW9uXHJcbiAqIC0gUmV0dXJucyBlbmNyeXB0ZWRfa2V5LCBpdiwgYW5kIGF1dGhfdGFnIGFzIEJhc2U2NCBzdHJpbmdzXHJcbiAqL1xyXG5cclxuY29uc3QgQUxHT1JJVEhNID0gJ2Flcy0yNTYtZ2NtJ1xyXG5jb25zdCBJVl9MRU5HVEggPSAxMiAvLyAxMiBieXRlcyBmb3IgR0NNXHJcbmNvbnN0IEtFWV9MRU5HVEggPSAzMiAvLyAzMiBieXRlcyBmb3IgQUVTLTI1NlxyXG5cclxuLyoqXHJcbiAqIEdldCBhbmQgdmFsaWRhdGUgdGhlIGVuY3J5cHRpb24gc2VjcmV0IGZyb20gZW52aXJvbm1lbnRcclxuICogRGVyaXZlcyBhIDMyLWJ5dGUgQUVTIGtleSB1c2luZyBTSEEtMjU2XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uS2V5KCk6IEJ1ZmZlciB7XHJcbiAgY29uc3Qgc2VjcmV0ID0gcHJvY2Vzcy5lbnYuQVBJX0tFWV9FTkNSWVBUSU9OX1NFQ1JFVFxyXG5cclxuICBpZiAoIXNlY3JldCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAnQVBJX0tFWV9FTkNSWVBUSU9OX1NFQ1JFVCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyByZXF1aXJlZCBidXQgbm90IHNldC4gJyArXHJcbiAgICAgICdQbGVhc2Ugc2V0IGl0IGluIHlvdXIgLmVudiBmaWxlLidcclxuICAgIClcclxuICB9XHJcblxyXG4gIGlmIChzZWNyZXQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAnQVBJX0tFWV9FTkNSWVBUSU9OX1NFQ1JFVCBlbnZpcm9ubWVudCB2YXJpYWJsZSBjYW5ub3QgYmUgZW1wdHkuICcgK1xyXG4gICAgICAnUGxlYXNlIHNldCBhIHZhbGlkIHNlY3JldCBpbiB5b3VyIC5lbnYgZmlsZS4nXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvLyBEZXJpdmUgYSAzMi1ieXRlIGtleSB1c2luZyBTSEEtMjU2XHJcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShzZWNyZXQpLmRpZ2VzdCgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmNyeXB0IGEgcGxhaW50ZXh0IHN0cmluZyB1c2luZyBBRVMtMjU2LUdDTVxyXG4gKiBcclxuICogQHBhcmFtIHBsYWludGV4dCAtIFRoZSB0ZXh0IHRvIGVuY3J5cHRcclxuICogQHJldHVybnMgT2JqZWN0IHdpdGggZW5jcnlwdGVkX2tleSwgaXYsIGFuZCBhdXRoX3RhZyAoYWxsIEJhc2U2NCBlbmNvZGVkKVxyXG4gKiBAdGhyb3dzIEVycm9yIGlmIGVuY3J5cHRpb24gZmFpbHMgb3IgaW5wdXRzIGFyZSBpbnZhbGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW5jcnlwdEFwaUtleShwbGFpbnRleHQ6IHN0cmluZyk6IHtcclxuICBlbmNyeXB0ZWRfa2V5OiBzdHJpbmdcclxuICBpdjogc3RyaW5nXHJcbiAgYXV0aF90YWc6IHN0cmluZ1xyXG59IHtcclxuICB0cnkge1xyXG4gICAgLy8gVmFsaWRhdGUgaW5wdXRcclxuICAgIGlmICghcGxhaW50ZXh0IHx8IHR5cGVvZiBwbGFpbnRleHQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxhaW50ZXh0IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJylcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGxhaW50ZXh0LnRyaW0oKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGFpbnRleHQgY2Fubm90IGJlIGVtcHR5JylcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgZW5jcnlwdGlvbiBrZXlcclxuICAgIGNvbnN0IGtleSA9IGdldEVuY3J5cHRpb25LZXkoKVxyXG5cclxuICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBJViAoMTIgYnl0ZXMgZm9yIEdDTSlcclxuICAgIGNvbnN0IGl2ID0gcmFuZG9tQnl0ZXMoSVZfTEVOR1RIKVxyXG5cclxuICAgIC8vIENyZWF0ZSBjaXBoZXJcclxuICAgIGNvbnN0IGNpcGhlciA9IGNyZWF0ZUNpcGhlcml2KEFMR09SSVRITSwga2V5LCBpdilcclxuXHJcbiAgICAvLyBFbmNyeXB0XHJcbiAgICBsZXQgZW5jcnlwdGVkID0gY2lwaGVyLnVwZGF0ZShwbGFpbnRleHQsICd1dGY4JylcclxuICAgIGVuY3J5cHRlZCA9IEJ1ZmZlci5jb25jYXQoW2VuY3J5cHRlZCwgY2lwaGVyLmZpbmFsKCldKVxyXG5cclxuICAgIC8vIEdldCBhdXRoZW50aWNhdGlvbiB0YWdcclxuICAgIGNvbnN0IGF1dGhUYWcgPSBjaXBoZXIuZ2V0QXV0aFRhZygpXHJcblxyXG4gICAgLy8gUmV0dXJuIEJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGVuY3J5cHRlZF9rZXk6IGVuY3J5cHRlZC50b1N0cmluZygnYmFzZTY0JyksXHJcbiAgICAgIGl2OiBpdi50b1N0cmluZygnYmFzZTY0JyksXHJcbiAgICAgIGF1dGhfdGFnOiBhdXRoVGFnLnRvU3RyaW5nKCdiYXNlNjQnKSxcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgLy8gUmUtdGhyb3cgd2l0aCBjb250ZXh0IGlmIGl0J3Mgb3VyIHZhbGlkYXRpb24gZXJyb3JcclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1BsYWludGV4dCcpKSB7XHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgICAvLyBXcmFwIGNyeXB0byBlcnJvcnNcclxuICAgIHRocm93IG5ldyBFcnJvcihgRW5jcnlwdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YClcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNyeXB0IGFuIGVuY3J5cHRlZCBBUEkga2V5IHVzaW5nIEFFUy0yNTYtR0NNXHJcbiAqIFxyXG4gKiBAcGFyYW0gZW5jcnlwdGVkX2tleSAtIEJhc2U2NCBlbmNvZGVkIGVuY3J5cHRlZCBkYXRhXHJcbiAqIEBwYXJhbSBpdiAtIEJhc2U2NCBlbmNvZGVkIGluaXRpYWxpemF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0gYXV0aF90YWcgLSBCYXNlNjQgZW5jb2RlZCBhdXRoZW50aWNhdGlvbiB0YWdcclxuICogQHJldHVybnMgRGVjcnlwdGVkIHBsYWludGV4dCBzdHJpbmdcclxuICogQHRocm93cyBFcnJvciBpZiBkZWNyeXB0aW9uIGZhaWxzIG9yIGlucHV0cyBhcmUgaW52YWxpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHRBcGlLZXkoXHJcbiAgZW5jcnlwdGVkX2tleTogc3RyaW5nLFxyXG4gIGl2OiBzdHJpbmcsXHJcbiAgYXV0aF90YWc6IHN0cmluZ1xyXG4pOiBzdHJpbmcge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBWYWxpZGF0ZSBhbGwgcmVxdWlyZWQgZmllbGRzIGV4aXN0XHJcbiAgICBpZiAoIWVuY3J5cHRlZF9rZXkgfHwgdHlwZW9mIGVuY3J5cHRlZF9rZXkgIT09ICdzdHJpbmcnIHx8IGVuY3J5cHRlZF9rZXkudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuY3J5cHRlZF9rZXkgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJylcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWl2IHx8IHR5cGVvZiBpdiAhPT0gJ3N0cmluZycgfHwgaXYudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l2IGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhdXRoX3RhZyB8fCB0eXBlb2YgYXV0aF90YWcgIT09ICdzdHJpbmcnIHx8IGF1dGhfdGFnLnRyaW0oKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoX3RhZyBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBkZWNyeXB0aW9uIGtleVxyXG4gICAgY29uc3Qga2V5ID0gZ2V0RW5jcnlwdGlvbktleSgpXHJcblxyXG4gICAgLy8gRGVjb2RlIEJhc2U2NCBzdHJpbmdzXHJcbiAgICBsZXQgZW5jcnlwdGVkQnVmZmVyOiBCdWZmZXJcclxuICAgIGxldCBpdkJ1ZmZlcjogQnVmZmVyXHJcbiAgICBsZXQgYXV0aFRhZ0J1ZmZlcjogQnVmZmVyXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgZW5jcnlwdGVkQnVmZmVyID0gQnVmZmVyLmZyb20oZW5jcnlwdGVkX2tleSwgJ2Jhc2U2NCcpXHJcbiAgICAgIGl2QnVmZmVyID0gQnVmZmVyLmZyb20oaXYsICdiYXNlNjQnKVxyXG4gICAgICBhdXRoVGFnQnVmZmVyID0gQnVmZmVyLmZyb20oYXV0aF90YWcsICdiYXNlNjQnKVxyXG4gICAgfSBjYXRjaCAoZGVjb2RlRXJyb3IpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEJhc2U2NCBlbmNvZGluZyBpbiBlbmNyeXB0ZWQgZGF0YScpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgSVYgbGVuZ3RoXHJcbiAgICBpZiAoaXZCdWZmZXIubGVuZ3RoICE9PSBJVl9MRU5HVEgpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElWIGxlbmd0aDogZXhwZWN0ZWQgJHtJVl9MRU5HVEh9IGJ5dGVzLCBnb3QgJHtpdkJ1ZmZlci5sZW5ndGh9YClcclxuICAgIH1cclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBhdXRoIHRhZyBsZW5ndGggKEdDTSBhdXRoIHRhZyBpcyBhbHdheXMgMTYgYnl0ZXMpXHJcbiAgICBpZiAoYXV0aFRhZ0J1ZmZlci5sZW5ndGggIT09IDE2KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhdXRoIHRhZyBsZW5ndGg6IGV4cGVjdGVkIDE2IGJ5dGVzLCBnb3QgJHthdXRoVGFnQnVmZmVyLmxlbmd0aH1gKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBkZWNpcGhlclxyXG4gICAgY29uc3QgZGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlcml2KEFMR09SSVRITSwga2V5LCBpdkJ1ZmZlcilcclxuICAgIGRlY2lwaGVyLnNldEF1dGhUYWcoYXV0aFRhZ0J1ZmZlcilcclxuXHJcbiAgICAvLyBEZWNyeXB0XHJcbiAgICBsZXQgZGVjcnlwdGVkID0gZGVjaXBoZXIudXBkYXRlKGVuY3J5cHRlZEJ1ZmZlcilcclxuICAgIGRlY3J5cHRlZCA9IEJ1ZmZlci5jb25jYXQoW2RlY3J5cHRlZCwgZGVjaXBoZXIuZmluYWwoKV0pXHJcblxyXG4gICAgcmV0dXJuIGRlY3J5cHRlZC50b1N0cmluZygndXRmOCcpXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIC8vIFJlLXRocm93IHZhbGlkYXRpb24gZXJyb3JzIGFzLWlzXHJcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAoXHJcbiAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3JlcXVpcmVkJykgfHxcclxuICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnSW52YWxpZCcpIHx8XHJcbiAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2xlbmd0aCcpXHJcbiAgICApKSB7XHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgICAvLyBXcmFwIGNyeXB0byBlcnJvcnMgKGluY2x1ZGluZyBhdXRoZW50aWNhdGlvbiBmYWlsdXJlcylcclxuICAgIHRocm93IG5ldyBFcnJvcihgRGVjcnlwdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YClcclxuICB9XHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJjcmVhdGVIYXNoIiwicmFuZG9tQnl0ZXMiLCJjcmVhdGVDaXBoZXJpdiIsImNyZWF0ZURlY2lwaGVyaXYiLCJBTEdPUklUSE0iLCJJVl9MRU5HVEgiLCJLRVlfTEVOR1RIIiwiZ2V0RW5jcnlwdGlvbktleSIsInNlY3JldCIsInByb2Nlc3MiLCJlbnYiLCJBUElfS0VZX0VOQ1JZUFRJT05fU0VDUkVUIiwiRXJyb3IiLCJ0cmltIiwibGVuZ3RoIiwidXBkYXRlIiwiZGlnZXN0IiwiZW5jcnlwdEFwaUtleSIsInBsYWludGV4dCIsImtleSIsIml2IiwiY2lwaGVyIiwiZW5jcnlwdGVkIiwiQnVmZmVyIiwiY29uY2F0IiwiZmluYWwiLCJhdXRoVGFnIiwiZ2V0QXV0aFRhZyIsImVuY3J5cHRlZF9rZXkiLCJ0b1N0cmluZyIsImF1dGhfdGFnIiwiZXJyb3IiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJkZWNyeXB0QXBpS2V5IiwiZW5jcnlwdGVkQnVmZmVyIiwiaXZCdWZmZXIiLCJhdXRoVGFnQnVmZmVyIiwiZnJvbSIsImRlY29kZUVycm9yIiwiZGVjaXBoZXIiLCJzZXRBdXRoVGFnIiwiZGVjcnlwdGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/encryption.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBrowserClient: () => (/* binding */ createBrowserClient),\n/* harmony export */   createServerClient: () => (/* binding */ createServerClient),\n/* harmony export */   getFreshServerClient: () => (/* binding */ getFreshServerClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/index.mjs\");\n\n/**\r\n * Server-side Supabase client with connection pooling\r\n * Uses service role key for admin operations and bypasses RLS\r\n * Configured to use pooled connections and avoid schema cache issues\r\n */ function createServerClient() {\n    const supabaseUrl = \"https://owwuktgpundilqkdbvxj.supabase.co\";\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    if (!supabaseUrl || !supabaseServiceKey) {\n        throw new Error(\"Missing Supabase environment variables\");\n    }\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseServiceKey, {\n        auth: {\n            autoRefreshToken: false,\n            persistSession: false\n        },\n        db: {\n            schema: \"public\"\n        },\n        global: {\n            headers: {\n                \"x-client-info\": \"rdms-server-pooled\",\n                \"Prefer\": \"return=representation\"\n            }\n        }\n    });\n}\n/**\r\n * Client-side Supabase client with connection pooling\r\n * Uses anon key and respects RLS policies\r\n */ function createBrowserClient() {\n    const supabaseUrl = \"https://owwuktgpundilqkdbvxj.supabase.co\";\n    const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im93d3VrdGdwdW5kaWxxa2RidnhqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5MTY5NTMsImV4cCI6MjA4MDQ5Mjk1M30.rt3AkjsQrEjbZImOGlcVLLYS1-WbHtit7Zu7hkEJn4s\";\n    if (!supabaseUrl || !supabaseAnonKey) {\n        throw new Error(\"Missing Supabase environment variables\");\n    }\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n        db: {\n            schema: \"public\"\n        },\n        global: {\n            headers: {\n                \"x-client-info\": \"rdms-browser-pooled\"\n            }\n        }\n    });\n}\n/**\r\n * Get a fresh client instance to avoid connection reuse issues\r\n * Useful when you need to ensure a new connection\r\n */ function getFreshServerClient() {\n    return createServerClient();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3VwYWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRTtBQUVwRTs7OztDQUlDLEdBQ00sU0FBU0M7SUFDZCxNQUFNQyxjQUFjQywwQ0FBb0M7SUFDeEQsTUFBTUcscUJBQXFCSCxRQUFRQyxHQUFHLENBQUNHLHlCQUF5QjtJQUVoRSxJQUFJLENBQUNMLGVBQWUsQ0FBQ0ksb0JBQW9CO1FBQ3ZDLE1BQU0sSUFBSUUsTUFBTTtJQUNsQjtJQUVBLE9BQU9SLG1FQUFZQSxDQUFDRSxhQUFhSSxvQkFBb0I7UUFDbkRHLE1BQU07WUFDSkMsa0JBQWtCO1lBQ2xCQyxnQkFBZ0I7UUFDbEI7UUFDQUMsSUFBSTtZQUNGQyxRQUFRO1FBQ1Y7UUFDQUMsUUFBUTtZQUNOQyxTQUFTO2dCQUNQLGlCQUFpQjtnQkFDakIsVUFBVTtZQUNaO1FBR0Y7SUFDRjtBQUNGO0FBRUE7OztDQUdDLEdBQ00sU0FBU0M7SUFDZCxNQUFNZCxjQUFjQywwQ0FBb0M7SUFDeEQsTUFBTWMsa0JBQWtCZCxrTkFBeUM7SUFFakUsSUFBSSxDQUFDRCxlQUFlLENBQUNlLGlCQUFpQjtRQUNwQyxNQUFNLElBQUlULE1BQU07SUFDbEI7SUFFQSxPQUFPUixtRUFBWUEsQ0FBQ0UsYUFBYWUsaUJBQWlCO1FBQ2hETCxJQUFJO1lBQ0ZDLFFBQVE7UUFDVjtRQUNBQyxRQUFRO1lBQ05DLFNBQVM7Z0JBQ1AsaUJBQWlCO1lBQ25CO1FBRUY7SUFDRjtBQUNGO0FBRUE7OztDQUdDLEdBQ00sU0FBU0k7SUFDZCxPQUFPbEI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9zdXBhYmFzZS50cz9jOTlmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCwgU3VwYWJhc2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXHJcblxyXG4vKipcclxuICogU2VydmVyLXNpZGUgU3VwYWJhc2UgY2xpZW50IHdpdGggY29ubmVjdGlvbiBwb29saW5nXHJcbiAqIFVzZXMgc2VydmljZSByb2xlIGtleSBmb3IgYWRtaW4gb3BlcmF0aW9ucyBhbmQgYnlwYXNzZXMgUkxTXHJcbiAqIENvbmZpZ3VyZWQgdG8gdXNlIHBvb2xlZCBjb25uZWN0aW9ucyBhbmQgYXZvaWQgc2NoZW1hIGNhY2hlIGlzc3Vlc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlcnZlckNsaWVudCgpOiBTdXBhYmFzZUNsaWVudCB7XHJcbiAgY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkxcclxuICBjb25zdCBzdXBhYmFzZVNlcnZpY2VLZXkgPSBwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZXHJcblxyXG4gIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlU2VydmljZUtleSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFN1cGFiYXNlIGVudmlyb25tZW50IHZhcmlhYmxlcycpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZVNlcnZpY2VLZXksIHtcclxuICAgIGF1dGg6IHtcclxuICAgICAgYXV0b1JlZnJlc2hUb2tlbjogZmFsc2UsXHJcbiAgICAgIHBlcnNpc3RTZXNzaW9uOiBmYWxzZSxcclxuICAgIH0sXHJcbiAgICBkYjoge1xyXG4gICAgICBzY2hlbWE6ICdwdWJsaWMnLFxyXG4gICAgfSxcclxuICAgIGdsb2JhbDoge1xyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ3gtY2xpZW50LWluZm8nOiAncmRtcy1zZXJ2ZXItcG9vbGVkJyxcclxuICAgICAgICAnUHJlZmVyJzogJ3JldHVybj1yZXByZXNlbnRhdGlvbicsXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIFVzZSBkZWZhdWx0IGZldGNoIC0gZG9uJ3Qgb3ZlcnJpZGUgdG8gYXZvaWQgaGVhZGVyIGNvbmZsaWN0cyB3aXRoIHVuZGljaVxyXG4gICAgICAvLyBDYWNoZS1idXN0aW5nIGFuZCBjb25uZWN0aW9uIHBvb2xpbmcgYXJlIGhhbmRsZWQgYXV0b21hdGljYWxseVxyXG4gICAgfSxcclxuICB9KVxyXG59XHJcblxyXG4vKipcclxuICogQ2xpZW50LXNpZGUgU3VwYWJhc2UgY2xpZW50IHdpdGggY29ubmVjdGlvbiBwb29saW5nXHJcbiAqIFVzZXMgYW5vbiBrZXkgYW5kIHJlc3BlY3RzIFJMUyBwb2xpY2llc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJDbGllbnQoKTogU3VwYWJhc2VDbGllbnQge1xyXG4gIGNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMXHJcbiAgY29uc3Qgc3VwYWJhc2VBbm9uS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVlcclxuXHJcbiAgaWYgKCFzdXBhYmFzZVVybCB8fCAhc3VwYWJhc2VBbm9uS2V5KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgU3VwYWJhc2UgZW52aXJvbm1lbnQgdmFyaWFibGVzJylcclxuICB9XHJcblxyXG4gIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xyXG4gICAgZGI6IHtcclxuICAgICAgc2NoZW1hOiAncHVibGljJyxcclxuICAgIH0sXHJcbiAgICBnbG9iYWw6IHtcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICd4LWNsaWVudC1pbmZvJzogJ3JkbXMtYnJvd3Nlci1wb29sZWQnLFxyXG4gICAgICB9LFxyXG4gICAgICAvLyBVc2UgZGVmYXVsdCBmZXRjaCAtIG5vIGN1c3RvbSBoZWFkZXJzIG5lZWRlZFxyXG4gICAgfSxcclxuICB9KVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgZnJlc2ggY2xpZW50IGluc3RhbmNlIHRvIGF2b2lkIGNvbm5lY3Rpb24gcmV1c2UgaXNzdWVzXHJcbiAqIFVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIGVuc3VyZSBhIG5ldyBjb25uZWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJlc2hTZXJ2ZXJDbGllbnQoKTogU3VwYWJhc2VDbGllbnQge1xyXG4gIHJldHVybiBjcmVhdGVTZXJ2ZXJDbGllbnQoKVxyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50IiwiY3JlYXRlU2VydmVyQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VTZXJ2aWNlS2V5IiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsIkVycm9yIiwiYXV0aCIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImRiIiwic2NoZW1hIiwiZ2xvYmFsIiwiaGVhZGVycyIsImNyZWF0ZUJyb3dzZXJDbGllbnQiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsImdldEZyZXNoU2VydmVyQ2xpZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/@supabase","vendor-chunks/next","vendor-chunks/tslib","vendor-chunks/iceberg-js","vendor-chunks/semver","vendor-chunks/jsonwebtoken","vendor-chunks/lodash.includes","vendor-chunks/jws","vendor-chunks/lodash.once","vendor-chunks/jwa","vendor-chunks/lodash.isinteger","vendor-chunks/ecdsa-sig-formatter","vendor-chunks/lodash.isplainobject","vendor-chunks/ms","vendor-chunks/lodash.isstring","vendor-chunks/lodash.isnumber","vendor-chunks/lodash.isboolean","vendor-chunks/safe-buffer","vendor-chunks/buffer-equal-constant-time"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fapi-keys%2Froute&page=%2Fapi%2Fapi-keys%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fapi-keys%2Froute.ts&appDir=C%3A%5CUsers%5Caksha%5CDocuments%5CGitHub%5Csalak%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Caksha%5CDocuments%5CGitHub%5Csalak&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();